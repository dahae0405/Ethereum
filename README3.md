# 이더리움 클라이언트
P2P 네트워크를 통해 다른 Ethereum 클라이언트와 통신하는 소프트웨어 응용 프로그램입니다. 
서로 다른 Ethereum 클라이언트 는 참조 사양 및 표준화 된 통신 프로토콜을 준수하는 경우 상호 운용 됩니다. 이러한 서로 다른 클라이언트는 서로 다른 팀과 서로 다른 프로그래밍 언어로 구현되지만 모두 동일한 프로토콜을 "말"하고 동일한 규칙을 따릅니다. 따라서 동일한 Ethereum 네트워크를 운영하고 상호 작용하는 데 모두 사용할 수 있습니다.

# 이더리움 클라이언트
Ethereum은 오픈 소스 프로젝트이며 모든 주요 클라이언트의 소스 코드는 오픈 소스 라이선스 (예 : LGPL v3.0)로 제공되며, 무료로 다운로드하여 어떤 목적 으로든 사용할 수 있습니다. 하지만 오픈 소스 는 단순히 무료로만 사용하는 것 이상을 의미합니다. 또한 Ethereum은 자원 봉사자의 열린 커뮤니티에 의해 개발되었으며 누구나 수정할 수 있음을 의미합니다. 더 많은 눈은 더 신뢰할 수있는 코드를 의미합니다.

Ethereum은 "Yellow Paper"라는 공식 사양에 의해 정의됩니다 ( [참조] 참조 ).

예를 들어 공식적인 방식으로 정의되지 않은 비트 코인과는 대조적입니다. 비트 코인의 "사양"이 참조 구현 인 비트 코인 코어 인 경우, 이더 리움의 사양은 영어와 수학적 (공식) 사양을 결합한 문서에 문서화되어 있습니다. 다양한 이더 리움 개선 제안과 함께이 공식 사양은 이더 리움 클라이언트 의 표준 동작을 정의합니다 . Yellow Paper는 이더 리움에 주요 변경 사항이있을 때 주기적으로 업데이트됩니다 .

Ethereum의 명확한 공식 사양의 결과로 Ethereum 클라이언트의 독립적으로 개발되었지만 상호 운용 가능한 소프트웨어 구현이 많이 있습니다. Ethereum은 일반적으로 좋은 것으로 간주되는 다른 블록 체인보다 네트워크에서 실행되는 구현의 다양성이 더 큽니다. 예를 들어, 특정 클라이언트의 구현 전략을 악용하면 개발자가 공격을 패치하는 동안 개발자를 번거롭게하는 반면 다른 클라이언트는 거의 영향을받지 않고 네트워크를 계속 실행하기 때문에 네트워크 공격을 방어하는 훌륭한 방법으로 입증되었습니다. .

이더 리움 네트워크
Ethereum Yellow Paper에 정의 된 공식 사양을 거의 준수하지만 서로 상호 운용 될 수도 있고 그렇지 않을 수도있는 다양한 Ethereum 기반 네트워크가 있습니다.

이러한 Ethereum 기반 네트워크에는 Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin 등이 있습니다. 대부분 프로토콜 수준에서 호환되지만 이러한 네트워크에는 종종 이더 리움 클라이언트 소프트웨어의 유지 관리자가 각 네트워크를 지원하기 위해 작은 변경을해야하는 기능이나 속성이 있습니다. 이 때문에 모든 버전의 이더 리움 클라이언트 소프트웨어가 모든 이더 리움 기반 블록 체인을 실행하는 것은 아닙니다.

현재 6 개의 다른 언어로 작성된 Ethereum 프로토콜의 6 가지 주요 구현이 있습니다.

Rust로 작성된 패리티

Go로 작성된 Geth

C ++로 작성된 cpp-ethereum

파이썬으로 작성된 pyethereum

스칼라로 작성된 Mantis

자바로 작성된 Harmony

이 섹션에서는 가장 일반적인 두 클라이언트 인 Parity와 Geth를 살펴 보겠습니다. 각 클라이언트를 사용하여 노드를 설정하는 방법을 보여주고 일부 명령 줄 옵션과 API (응용 프로그래밍 인터페이스)를 살펴 봅니다.

전체 노드를 실행해야합니까?
블록 체인의 건강, 탄력성 및 검열 저항은 독립적으로 운영되고 지리적으로 분산 된 풀 노드가 많이있는 블록 체인에 달려 있습니다. 각 전체 노드는 다른 새로운 노드가 작업을 부트 스트랩하기 위해 블록 데이터를 얻는 데 도움이 될뿐만 아니라 운영자에게 모든 거래 및 계약에 대한 권위 있고 독립적 인 검증을 제공 할 수 있습니다.

그러나 전체 노드를 실행하면 하드웨어 리소스 및 대역폭 비용이 발생합니다. 전체 노드는 최대 300GB의 데이터 (클라이언트 구성에 따라 2021 년 3 월 현재)를 다운로드하여 로컬 하드 드라이브에 저장할 수 있습니다. 이 데이터 부담은 새로운 트랜잭션과 블록이 추가됨에 따라 매일 매우 빠르게 증가합니다. 이 주제 는 전체 노드에 대한 하드웨어 요구 사항에서 자세히 설명 합니다.

라이브 메인 넷 네트워크 에서 실행되는 전체 노드 는 이더 리움 개발에 필요하지 않습니다. 테스트 넷 노드 (소규모 공개 테스트 블록 체인 중 하나에 연결), Ganache와 같은 로컬 프라이빗 블록 체인 또는 Infura와 같은 서비스 제공 업체가 제공하는 클라우드 기반 이더 리움 클라이언트를 사용하여 필요한 거의 모든 작업을 수행 할 수 있습니다. .

또한 블록 체인의 로컬 사본을 저장하지 않거나 블록 및 트랜잭션을 검증하지 않는 원격 클라이언트를 실행할 수도 있습니다. 이러한 클라이언트는 지갑의 기능을 제공하고 트랜잭션을 생성하고 브로드 캐스트 할 수 있습니다. 원격 클라이언트는 자체 풀 노드, 퍼블릭 블록 체인, 퍼블릭 또는 허가 된 (권한 증명) 테스트 넷 또는 프라이빗 로컬 블록 체인과 같은 기존 네트워크에 연결하는 데 사용할 수 있습니다. 실제로 MetaMask, Emerald Wallet, MyEtherWallet 또는 MyCrypto 와 같은 원격 클라이언트를 사용하여 모든 다른 노드 옵션을 편리하게 전환 할 수 있습니다.

"원격 클라이언트"와 "지갑"이라는 용어는 약간의 차이가 있지만 같은 의미로 사용됩니다. 일반적으로 원격 클라이언트는 지갑의 트랜잭션 기능 외에도 API (예 : web3.js API)를 제공합니다.

Ethereum의 원격 지갑 개념을 라이트 클라이언트 의 개념과 혼동하지 마십시오 (비트 코인의 단순화 된 지불 확인 클라이언트와 유사 함). 라이트 클라이언트는 블록 헤더의 유효성을 검사하고 Merkle 증명을 사용하여 블록 체인에 트랜잭션이 포함되었는지 확인하고 그 효과를 결정하여 전체 노드와 유사한 수준의 보안을 제공합니다. 반대로 Ethereum 원격 클라이언트는 블록 헤더 또는 트랜잭션의 유효성을 검사하지 않습니다. 그들은 블록 체인에 대한 액세스 권한을 부여하기 위해 완전한 클라이언트를 전적으로 신뢰하므로 상당한 보안 및 익명 성 보장을 잃게됩니다. 직접 실행하는 전체 클라이언트를 사용하여 이러한 문제를 완화 할 수 있습니다.

전체 노드의 장점 및 단점
전체 노드를 실행하도록 선택하면 연결하는 네트워크의 운영에 도움이되지만 약간의 비용이 발생합니다. 몇 가지 장점과 단점을 살펴 보겠습니다.

장점 :

이더 리움 기반 네트워크의 복원력 및 검열 저항을 지원합니다.

모든 거래를 정식으로 검증합니다.

중개자없이 퍼블릭 블록 체인의 모든 계약과 상호 작용할 수 있습니다.

중개자없이 계약을 퍼블릭 블록 체인에 직접 배포 할 수 있습니다.

오프라인에서 블록 체인 상태 (계정, 계약 등)를 조회 (읽기 전용) 할 수 있습니다.

읽고있는 정보를 제 3 자에게 알리지 않고 블록 체인을 쿼리 할 수 ​​있습니다.

단점 :

상당히 증가하는 하드웨어 및 대역폭 리소스가 필요합니다.

처음 시작할 때 완전히 동기화하는 데 며칠이 걸릴 수 있습니다.

동기화 상태를 유지하려면 유지 관리, 업그레이드 및 온라인 상태를 유지해야합니다.

Public Testnet 장점 및 단점
전체 노드 실행 여부에 관계없이 공용 테스트 넷 노드를 실행하고 싶을 것입니다. 공개 테스트 넷 사용의 장점과 단점을 살펴 보겠습니다.

장점 :

테스트 넷 노드는 메인 넷에 비해 훨씬 적은 양의 데이터를 동기화하고 저장해야합니다 (네트워크에 따라 약 75GB).

테스트 넷 노드는 훨씬 짧은 시간에 완전히 동기화 할 수 있습니다.

계약을 전개하거나 거래를하려면 가치가없고 여러 "수도꼭지"에서 무료로 얻을 수있는 테스트 에테르가 필요합니다.

테스트 넷은 "실시간"으로 실행되는 다른 많은 사용자 및 계약이있는 공용 블록 체인입니다.

단점 :

테스트 넷에서는 "실제"돈을 사용할 수 없습니다. 테스트 에테르에서 실행됩니다. 결과적으로 위험에 처한 것이 없기 때문에 실제 적에 대한 보안을 테스트 할 수 없습니다.

테스트 넷에서 현실적으로 테스트 할 수없는 퍼블릭 블록 체인의 몇 가지 측면이 있습니다. 예를 들어, 거래를 보내는 데 필요한 거래 수수료는 가스가 무료이기 때문에 테스트 넷에서는 고려되지 않습니다. 또한 테스트 넷은 때때로 퍼블릭 메인 넷처럼 네트워크 혼잡을 경험하지 않습니다.

로컬 블록 체인 시뮬레이션의 장점과 단점
많은 테스트 목적에서 가장 좋은 옵션은 단일 인스턴스 프라이빗 블록 체인을 시작하는 것입니다. Ganache (이전의 testrpc)는 다른 참가자없이 상호 작용할 수있는 가장 인기있는 로컬 블록 체인 시뮬레이션 중 하나입니다. 공개 테스트 넷의 많은 장단점을 공유하지만 몇 가지 차이점도 있습니다.

장점 :

동기화가없고 디스크에 데이터가 거의 없습니다. 당신은 첫 번째 블록을 직접 채굴합니다.

테스트 에테르를 얻을 필요가 없습니다. Ganache는 테스트를 위해 이미 ether를 보유한 계정으로 초기화됩니다.

다른 사용자는없고 나만

다른 계약은 없으며 기존 Ethereum 노드를 분기하는 옵션을 사용하지 않는 한 시작 후 배포 한 계약 만

단점 :

다른 사용자가 없다는 것은 퍼블릭 블록 체인과 동일하게 작동하지 않는다는 것을 의미합니다. 트랜잭션 공간이나 트랜잭션 순서에 대한 경쟁이 없습니다 .

귀하 이외의 채굴자는 채굴이 더 예측 가능하다는 것을 의미합니다. 따라서 퍼블릭 블록 체인에서 발생하는 일부 시나리오를 테스트 할 수 없습니다.

기존 이더 리움 노드를 분기하는 경우, 그렇지 않은 경우 정리되었을 수있는 블록의 상태와 상호 작용하려면 보관 노드 여야합니다.

이더 리움 클라이언트 실행
시간과 자원이 있다면 프로세스에 대해 더 많이 배우려는 경우에도 전체 노드를 실행해야합니다. 이 섹션에서는 Ethereum 클라이언트 Parity 및 Geth를 다운로드, 컴파일 및 실행하는 방법을 다룹니다. 이를 위해서는 운영 체제에서 명령 줄 인터페이스를 사용하는 데 어느 정도 익숙해야합니다. 이러한 클라이언트를 전체 노드로 실행하든, 테스트 넷 노드로 실행하든, 로컬 프라이빗 블록 체인에 대한 클라이언트로 실행하든 상관없이 이러한 클라이언트를 설치할 가치가 있습니다.

전체 노드에 대한 하드웨어 요구 사항
시작하기 전에 이더 리움 풀 노드를 실행하기에 충분한 리소스가있는 컴퓨터가 있는지 확인해야합니다. 이더 리움 블록 체인의 전체 사본을 저장하려면 최소 300GB의 디스크 공간이 필요합니다. Ethereum 테스트 넷에서 전체 노드를 실행하려면 최소한 75GB가 추가로 필요합니다. 375GB의 블록 체인 데이터를 다운로드하는 데 시간이 오래 걸릴 수 있으므로 빠른 인터넷 연결에서 작업하는 것이 좋습니다.

이더 리움 블록 체인 동기화는 입 / 출력 (I / O) 집약적입니다. 솔리드 스테이트 드라이브 (SSD)를 사용하는 것이 가장 좋습니다. 기계식 하드 디스크 드라이브 (HDD)가있는 경우 캐시로 사용하려면 최소 8GB의 RAM이 필요합니다. 그렇지 않으면 시스템이 너무 느려서 완전히 동기화하지 못할 수 있습니다.

최소 요건:

2 개 이상의 코어가있는 CPU

최소 300GB의 여유 저장 공간

최소 4GB RAM (SSD 포함), 8GB + (HDD 포함)

8MBit / sec 다운로드 인터넷 서비스

이는 이더 리움 기반 블록 체인의 전체 (그러나 정리 된) 사본을 동기화하기위한 최소 요구 사항입니다.

Parity 코드베이스를 작성하는 시점에서 리소스가 더 가볍기 때문에 제한된 하드웨어로 실행하는 경우 Parity를 ​​사용하면 더 나은 결과를 볼 수 있습니다.

합리적인 시간 내에 동기화하고이 책에서 논의하는 모든 개발 도구, 라이브러리, 클라이언트 및 블록 체인을 저장하려면 더 뛰어난 성능의 컴퓨터를 원할 것입니다.

권장 사양 :

코어가 4 개 이상인 고속 CPU

16GB 이상의 RAM

최소 500GB의 여유 공간이있는 빠른 SSD

25MBit / sec 이상의 다운로드 인터넷 서비스

블록 체인의 크기가 얼마나 빨리 증가하고 더 많은 디스크 공간이 필요한지 예측하기 어렵 기 때문에 동기화를 시작하기 전에 블록 체인의 최신 크기를 확인하는 것이 좋습니다.

노트
여기에 나열된 디스크 크기 요구 사항은 블록 체인이 이전 상태 데이터의 "정리"되는 기본 설정으로 노드를 실행한다고 가정합니다. 대신 모든 상태가 디스크에 유지되는 전체 "보관"노드를 실행하는 경우 1TB 이상의 디스크 공간이 필요할 수 있습니다.

이 링크는 블록 체인 크기에 대한 최신 추정치를 제공합니다.

이더 리움

이더 리움 클래식

클라이언트 (노드) 구축 및 실행을위한 소프트웨어 요구 사항
이 섹션에서는 Parity 및 Geth 클라이언트 소프트웨어를 다룹니다. 또한 Unix와 유사한 명령 줄 환경을 사용하고 있다고 가정합니다. 예제는 bash 셸 (명령 줄 실행 환경)을 실행하는 Ubuntu GNU / Linux 운영 체제에 나타나는 명령 및 출력을 보여줍니다.

일반적으로 모든 블록 체인에는 자체 버전의 Geth가 있으며 Parity는 동일한 클라이언트 다운로드 로 여러 이더 리움 기반 블록 체인 (Ethereum, Ethereum Classic, Ellaism , Expanse, Musicoin)에 대한 지원을 제공합니다 .

팁
이 장의 많은 예에서 "터미널"응용 프로그램을 통해 액세스되는 운영 체제의 명령 줄 인터페이스 ( "쉘"이라고도 함)를 사용합니다. 쉘은 프롬프트를 표시합니다. 명령을 입력하면 쉘이 다음 명령에 대한 새 프롬프트와 텍스트로 응답합니다. 프롬프트는 시스템에서 다르게 보일 수 있지만 다음 예에서는 $ 기호로 표시됩니다. 예제에서 $ 기호 뒤에 텍스트가 표시되면 $ 기호를 입력하지 말고 바로 뒤에 명령 (굵게 표시)을 입력 한 다음 Enter 키를 눌러 명령을 실행합니다. 예에서 각 명령 아래의 행은 해당 명령에 대한 운영 체제의 응답입니다. 다음 $ 접두사를 보면 새 명령임을 알 수 있으며 프로세스를 반복해야합니다.

시작하기 전에 일부 소프트웨어를 설치해야 할 수 있습니다. 현재 사용중인 컴퓨터에서 소프트웨어 개발을 한 적이 없다면 몇 가지 기본 도구를 설치해야 할 것입니다. 다음 예제에서는 소스 코드 관리 시스템 인 git을 설치해야합니다. golang, Go 프로그래밍 언어 및 표준 라이브러리 및 시스템 프로그래밍 언어 인 Rust.

https://git-scm.com 의 지침에 따라 Git을 설치할 수 있습니다 .

이동의 지침에 따라 설치 될 수 https://golang.org , 또는 https://github.com/golang/go/wiki/Ubuntu 당신이 우분투를 사용하는 경우.

노트
Geth 요구 사항은 다양하지만 Go 버전 1.13 이상을 고수하면 대부분의 Geth 버전을 컴파일 할 수 있습니다. 물론, 당신이 선택한 Geth에 대한 문서를 항상 참조해야합니다.

운영 체제에 설치되어 있거나 시스템의 패키지 관리자에서 사용할 수있는 golang 버전이 1.13보다 훨씬 오래되었을 수 있습니다. 그렇다면 제거하고 https://golang.org/ 에서 최신 버전을 설치 하십시오 .

Rust는 https://www.rustup.rs/ 의 지침에 따라 설치할 수 있습니다 .

노트
패리티에는 Rust 버전 1.27 이상이 필요합니다.

패리티에는 OpenSSL 및 libudev와 같은 일부 소프트웨어 라이브러리도 필요합니다. Ubuntu 또는 Debian GNU / Linux 호환 시스템에이를 설치하려면 다음 명령을 사용하십시오 .

$ sudo apt-get install openssl libssl-dev libudev-dev cmake clang
다른 운영 체제의 경우 OS의 패키지 관리자를 사용하거나 Wiki 지침 에 따라 필요한 라이브러리를 설치하십시오.

이제 git, golang, Rust 및 필요한 라이브러리가 설치되었으므로 작업을 시작하겠습니다!

동등
패리티는 풀 노드 이더 리움 클라이언트와 DApp 브라우저의 구현입니다. 모듈 식의 안전하고 확장 가능한 이더 리움 클라이언트를 구축하기 위해 시스템 프로그래밍 언어 인 Rust로 "처음부터"작성되었습니다. Parity는 영국 회사 인 Parity Tech에서 개발했으며 GPLv3 무료 소프트웨어 라이선스에 따라 출시되었습니다.

노트
공개 :이 책의 저자 중 한 명인 Dr. Gavin Wood는 Parity Tech의 창립자이며 Parity 클라이언트의 많은 부분을 저술했습니다. 패리티는 설치된 이더 리움 클라이언트 기반의 약 25 %를 나타냅니다.

Parity를 ​​설치하려면 Rust 패키지 관리자 카고를 사용하거나 GitHub에서 소스 코드를 다운로드 할 수 있습니다. 패키지 관리자는 소스 코드도 다운로드하므로 두 옵션간에 큰 차이가 없습니다. 다음 섹션에서는 Parity를 ​​직접 다운로드하고 컴파일하는 방법을 보여줍니다.

패리티 설치
패리티 위키 서로 다른 환경과 용기에 패리티를 구축하기위한 이벤트 안내. 소스에서 패리티를 빌드하는 방법을 보여 드리겠습니다. 이것은 rustup을 사용하여 Rust를 이미 설치했다고 가정합니다 ( 클라이언트 (노드) 빌드 및 실행을위한 소프트웨어 요구 사항 참조 ).

먼저 GitHub에서 소스 코드를 가져옵니다.

$ git clone https://github.com/paritytech/parity
그런 다음 패리티 디렉토리로 변경하고 cargo를 사용하여 실행 파일을 빌드하십시오.

$ cd parity 
$ cargo install --path.
모든 것이 잘되면 다음과 같은 내용이 표시됩니다.

$ cargo install --path.
parity-ethereum v2.7.0 (/ root / parity) 설치
crates.io 색인 업데이트
git 저장소`https : // github.com / paritytech / rust-ctrlc.git` 업데이트
git 저장소 업데이트`https : // github.com / paritytech / app-dirs-rs` git 저장소 업데이트

 [...]

parity-ethereum v2.7.0 (/ root / parity) 컴파일
10 분 16 초 만에 [최적화 된] 대상 출시 완료
/root/.cargo/bin/parity 설치
설치된 패키지`parity-ethereum v2.7.0 (/ root / parity)`(`parity` 실행 가능)
$
--version 옵션을 호출하여 패리티가 설치되어 있는지 확인하고 실행합니다.

$ 패리티 --version
패리티 이더 리움 클라이언트.
  버전 Parity-Ethereum / v2.7.0-unstable-b69a33b3a-20200124 / x86_64-unknown-linux-gnu / rustc1.40.0
저작권 2015-2020 Parity Technologies (UK) Ltd.
라이선스 GPLv3 + : GNU GPL 버전 3 이상 http://gnu.org/licenses/gpl.html.
이것은 자유 소프트웨어입니다. 여러분은 자유롭게 변경하고 재배포 할 수 있습니다.
법이 허용하는 한 보증은 없습니다.

작성자 : Wood / Paronyan / Kotewicz / Drwięga / Volf / Greeff
   Habermeier / Czaban / Gotchac / Redman / Nikolsky
   Schoedon / Tang / Adolfsson / Silva / Palm / Hirsz et al.
$
큰! 이제 Parity가 설치되었으므로 블록 체인을 동기화하고 몇 가지 기본 명령 줄 옵션을 시작할 수 있습니다.

Go-Ethereum (Geth)
Geth는 Ethereum Foundation에서 적극적으로 개발 한 Go 언어 구현이므로 Ethereum 클라이언트의 "공식"구현으로 간주됩니다. 일반적으로 모든 이더 리움 기반 블록 체인에는 자체 Geth 구현이 있습니다. Geth를 실행하는 경우 다음 리포지토리 링크 중 하나를 사용하여 블록 체인에 대한 올바른 버전을 가져 오는 것이 좋습니다.

이더 리움 (또는 https://geth.ethereum.org/ )

이더 리움 클래식

Ellaism

팽창

Musicoin

Ubiq

노트
이 지침을 건너 뛰고 선택한 플랫폼에 대해 미리 컴파일 된 바이너리를 설치할 수도 있습니다. 사전 컴파일 된 릴리스는 설치가 훨씬 쉽고 여기에 나열된 저장소의 "릴리스"섹션에서 찾을 수 있습니다. 그러나 소프트웨어를 직접 다운로드하고 컴파일하면 더 많은 정보를 얻을 수 있습니다.

저장소 복제
첫 번째 단계는 Git 저장소를 복제하여 소스 코드의 복사본을 얻는 것입니다.

선택한 저장소의 로컬 복제본을 만들려면 홈 디렉토리 또는 개발에 사용하는 디렉토리에서 다음과 같이 git 명령을 사용하십시오.

$ git clone <저장소 링크>
저장소가 로컬 시스템에 복사되면 진행률 보고서가 표시되어야합니다.

'go-ethereum'으로 복제 ...
원격 : 개체 열거 : 86915, 완료.
원격 : 총 86915 (델타 0), 재사용 0 (델타 0), 팩 재사용 86915
개체 수신 : 100 % (86915/86915), 134.73MiB | 29.30 MiB / s, 완료.
델타 해결 : 100 % (57590/57590), 완료.
큰! 이제 Geth의 로컬 복사본이 있으므로 플랫폼 용 실행 파일을 컴파일 할 수 있습니다.

소스 코드에서 Geth 빌드
Geth를 빌드하려면 소스 코드를 다운로드 한 디렉토리로 변경하고 make 명령을 사용합니다.

$ cd go-ethereum 
$ makeh 만들기
모든 것이 순조롭게 진행되면 Go 컴파일러가 geth 실행 파일을 생성 할 때까지 각 구성 요소를 빌드하는 것을 볼 수 있습니다.

build / env.sh go run build / ci.go install ./cmd/geth
>>> / usr / local / go / bin / go install -ldflags -X main.gitCommit = 58a1e13e6dd7f52a1d ...
github.com/ethereum/go-ethereum/common/hexutil
github.com/ethereum/go-ethereum/common/math
github.com/ethereum/go-ethereum/crypto/sha3
github.com/ethereum/go-ethereum/rlp
github.com/ethereum/go-ethereum/crypto/secp256k1
github.com/ethereum/go-ethereum/common
[...]
github.com/ethereum/go-ethereum/cmd/utils
github.com/ethereum/go-ethereum/cmd/geth
건물 완료.
"build / bin / geth"를 실행하여 geth를 시작합니다.
$
실제로 실행을 시작하지 않고 geth가 작동하는지 확인합시다.

$ ./build/bin/geth 버전

게스
버전 : 1.9.11-unstable
힘내 커밋 : 0b284f6c6cfc6df452ca23f9454ee16a6330cb8e
Git 커밋 날짜 : 20200123
아키텍처 : amd64
프로토콜 버전 : [64 63]
Go 버전 : go1.13.4
운영 체제 : linux
[...]
geth 버전 명령은 약간 다른 정보를 표시 할 수 있지만 여기에 표시된 것과 매우 유사한 버전 보고서가 표시되어야합니다.

다음 섹션에서는 이더 리움 블록 체인의 초기 동기화 문제에 대해 설명합니다.

이더 리움 기반 블록 체인의 첫 번째 동기화
전통적으로 이더 리움 블록 체인을 동기화 할 때 클라이언트는 처음부터 모든 블록과 모든 트랜잭션을 다운로드하고 유효성을 검사합니다. 즉, 제네시스 블록에서.

이런 방식으로 블록 체인을 완전히 동기화하는 것이 가능하지만, 이러한 유형의 동기화는 시간이 매우 오래 걸리고 리소스 요구 사항이 높습니다 (더 많은 RAM이 필요하며 빠르지 않으면 실제로 매우 오랜 시간이 걸립니다). 저장).

많은 이더 리움 기반 블록 체인은 2016 년 말에 서비스 거부 공격의 피해자였습니다. 영향을받는 블록 체인은 전체 동기화를 수행 할 때 느리게 동기화되는 경향이 있습니다.

예를 들어, Ethereum에서 새로운 클라이언트는 블록 2,283,397에 도달 할 때까지 빠르게 진행됩니다. 이 블록은 2016 년 9 월 18 일에 채굴되었으며 DoS 공격의 시작을 표시합니다. 이 블록에서 블록 2,700,031 (2016 년 11 월 26 일)까지 트랜잭션 검증은 매우 느리고 메모리 집약적이며 I / O 집약적입니다. 이로 인해 검증 시간이 블록 당 1 분을 초과합니다. Ethereum은 DoS 공격에서 악용 된 근본적인 취약성을 해결하기 위해 하드 포크를 사용하여 일련의 업그레이드를 구현했습니다. 이러한 업그레이드는 스팸 거래로 생성 된 약 2 천만 개의 빈 계정을 제거하여 블록 체인을 정리했습니다.

전체 유효성 검사로 동기화하는 경우 클라이언트 속도가 느려지고 DoS 공격의 영향을받는 블록을 유효성 검사하는 데 며칠 또는 더 오래 걸릴 수 있습니다.

다행히도 대부분의 이더 리움 클라이언트는 이제 기본적으로 블록 체인의 끝 부분에 동기화 될 때까지 트랜잭션의 전체 유효성 검사를 건너 뛰고 전체 유효성 검사를 다시 시작하는 "빠른"동기화를 수행합니다.

Geth는 기본적으로 Ethereum에 대해 빠른 동기화를 수행합니다. 선택한 다른 이더 리움 체인에 대한 특정 지침을 참조해야 할 수도 있습니다.

패리티는 기본적으로 빠른 동기화도 수행합니다.

노트
Geth는 빈 블록 데이터베이스로 시작할 때만 빠른 동기화를 수행 할 수 있습니다. 빠른 모드없이 이미 동기화를 시작한 경우 Geth는 전환 할 수 없습니다. 전체 유효성 검사로 계속 동기화하는 것보다 블록 체인 데이터 디렉터리를 삭제하고 처음부터 빠른 동기화를 시작하는 것이 더 빠릅니다. 블록 체인 데이터를 삭제할 때 지갑을 삭제하지 않도록주의하세요!

Geth 또는 Parity 실행
이제 "첫 번째 동기화"의 문제를 이해 했으므로 이더 리움 클라이언트를 시작하고 블록 체인을 동기화 할 준비가되었습니다. Geth와 Parity 모두에 대해 --help 옵션을 사용하여 모든 구성 매개 변수를 볼 수 있습니다. 기본 설정은 일반적으로 합리적이고 대부분의 용도에 적합합니다. 필요에 맞게 선택적 매개 변수를 구성하는 방법을 선택한 다음 Geth 또는 Parity를 ​​시작하여 체인을 동기화하십시오. 그럼 기다려 ...

팁
이더 리움 블록 체인을 동기화하는 데는 RAM이 많은 매우 빠른 시스템에서 반나절부터 느린 시스템에서는 며칠이 걸립니다.

JSON-RPC 인터페이스
이더 리움 클라이언트는 애플리케이션 프로그래밍 인터페이스와 JSON (JavaScript Object Notation)으로 인코딩 된 일련의 원격 프로 시저 호출 (RPC) 명령을 제공합니다. 이것을 JSON-RPC API 라고합니다 . 본질적으로 JSON-RPC API는 이더 리움 클라이언트를 이더 리움 네트워크 및 블록 체인에 대한 게이트웨이 로 사용하는 프로그램을 작성할 수있는 인터페이스입니다 .

일반적으로 RPC 인터페이스는 포트 8545에서 HTTP 서비스로 제공됩니다. 보안상의 이유로 기본적으로 localhost (사용자 컴퓨터의 IP 주소, 127.0.0.1)의 연결 만 허용하도록 제한됩니다.

JSON-RPC API에 액세스하려면 사용 가능한 각 RPC 명령에 해당하는 "스텁"함수 호출을 제공하는 특수 라이브러리 (선택한 프로그래밍 언어로 작성)를 사용하거나 수동으로 HTTP 요청을 구성하고 JSON을 전송 / 수신 할 수 있습니다. -인코딩 된 요청. curl과 같은 일반 명령 줄 HTTP 클라이언트를 사용하여 RPC 인터페이스를 호출 할 수도 있습니다. 시도해 봅시다. 먼저 RPC 인터페이스에 대한 HTTP 액세스를 허용하도록 --rpc로 구성된 Geth가 실행되고 있는지 확인한 다음 새 터미널 창으로 전환합니다 (예 : 기존 창에서 Ctrl-Shift-N 또는 Ctrl-Shift-T 사용). 터미널 창)에 표시된대로 :

$ curl -X POST -H "Content-Type : application / json"--data \
  '{ "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 1}'\
  http : // localhost : 8545

{ "jsonrpc": "2.0", "id": 1,
"result": "Geth / v1.9.11-unstable-0b284f6c-20200123 / linux-amd64 / go1.13.4"}
이 예에서는 curl을 사용하여 http : // localhost : 8545 주소에 대한 HTTP 연결을 만듭니다 . 포트 8545에서 HTTP 서비스로 JSON-RPC API를 제공하는 geth를 이미 실행하고 있습니다. curl에 HTTP POST 명령을 사용하고 콘텐츠를 application / json 유형으로 식별하도록 지시합니다. 마지막으로 HTTP 요청의 데이터 구성 요소로 JSON 인코딩 요청을 전달합니다. 대부분의 명령 줄은 HTTP 연결을 올바르게 만들기 위해 curl을 설정하는 것입니다. 흥미로운 부분은 우리가 실행하는 실제 JSON-RPC 명령입니다.

{ "jsonrpc": "2.0", "method": "web3_clientVersion", "params": [], "id": 1}
JSON-RPC 요청은 JSON-RPC 2.0 사양 에 따라 형식이 지정됩니다 . 각 요청에는 다음 네 가지 요소가 포함됩니다.

jsonrpc
JSON-RPC 프로토콜의 버전입니다. 정확히 "2.0"이어야합니다.

방법
호출 할 메서드의 이름입니다.

매개 변수
메소드 호출 중에 사용할 매개 변수 값을 보유하는 구조화 된 값입니다. 이 구성원은 생략 될 수 있습니다.

신분증
포함 된 경우 문자열, 숫자 또는 NULL 값을 포함해야하는 클라이언트가 설정 한 식별자입니다. 서버는 포함 된 경우 응답 객체에서 동일한 값으로 응답해야합니다. 이 멤버는 두 개체 간의 컨텍스트를 연관시키는 데 사용됩니다.

팁
id 매개 변수는 주로 단일 JSON-RPC 호출로 여러 요청을 할 때 사용되며,이를 일괄 처리 라고 합니다. 일괄 처리는 모든 요청에 ​​대해 새로운 HTTP 및 TCP 연결의 오버 헤드를 방지하는 데 사용됩니다. 예를 들어 Ethereum 컨텍스트에서 하나의 HTTP 연결을 통해 수천 개의 트랜잭션을 검색하려는 경우 일괄 처리를 사용합니다. 일괄 처리 할 때 각 요청에 대해 다른 ID를 설정 한 다음 JSON-RPC 서버의 각 응답에있는 ID와 일치시킵니다. 이를 구현하는 가장 쉬운 방법은 카운터를 유지하고 각 요청의 값을 증가시키는 것입니다.

우리가받는 응답은 다음과 같습니다.

{ "jsonrpc": "2.0", "id": 1,
"result": "Geth / v1.9.11-unstable-0b284f6c-20200123 / linux-amd64 / go1.13.4"}
이는 JSON-RPC API가 Geth 클라이언트 버전 1.9.11에서 제공되고 있음을 나타냅니다.

좀 더 흥미로운 것을 시도해 봅시다. 다음 예에서는 wei의 현재 가스 가격을 JSON-RPC API에 요청합니다.

$ curl -X POST -H "Content-Type : application / json"--data \
  '{ "jsonrpc": "2.0", "method": "eth_gasPrice", "params": [], "id": 4213}'\
  http : // localhost : 8545

{ "jsonrpc": "2.0", "id": 4213, "result": "0x430e23400"}
응답 0x430e23400은 현재 가스 가격이 18gwei (gigawei 또는 billion wei)임을 알려줍니다. 우리처럼 16 진수로 생각하지 않는다면 약간의 bash-fu를 사용하여 명령 줄에서 십진수로 변환 할 수 있습니다.

$ 에코 $ ((0x430e23400))

18000000000
전체 JSON-RPC API는 Ethereum wiki 에서 조사 할 수 있습니다 .

패리티의 Geth 호환 모드
Parity에는 Geth에서 제공하는 것과 동일한 JSON-RPC API를 제공하는 특별한 "Geth 호환성 모드"가 있습니다.이 모드에서 Parity를 ​​실행하려면 --geth 스위치를 사용하십시오.

$ 패리티 --geth
원격 이더 리움 클라이언트
원격 클라이언트는 전체 클라이언트 기능의 하위 집합을 제공합니다. 전체 이더 리움 블록 체인을 저장하지 않기 때문에 설정이 더 빠르고 데이터 저장 공간이 훨씬 적습니다.

이러한 클라이언트는 일반적으로 다음 중 하나 이상을 수행 할 수있는 기능을 제공합니다.

지갑에서 개인 키와 이더 리움 주소를 관리합니다.

트랜잭션을 생성, 서명 및 브로드 캐스트합니다.

데이터 페이로드를 사용하여 스마트 계약과 상호 작용합니다.

DApp을 탐색하고 상호 작용합니다.

블록 탐색기와 같은 외부 서비스에 대한 링크를 제공합니다.

이더 단위를 변환하고 외부 소스에서 환율을 검색합니다.

web3 인스턴스를 웹 브라우저에 JavaScript 객체로 삽입합니다.

다른 클라이언트가 브라우저에 제공 / 주입 한 web3 인스턴스를 사용합니다.

로컬 또는 원격 이더 리움 노드에서 RPC 서비스에 액세스합니다.

모바일 (스마트 폰) 지갑과 같은 일부 원격 클라이언트는 기본 지갑 기능 만 제공합니다. 다른 원격 클라이언트는 완전한 DApp 브라우저입니다. 원격 클라이언트는 일반적으로 다른 곳에서 실행되는 전체 노드에 연결하여 이더 리움 블록 체인의 로컬 사본을 동기화하지 않고 전체 노드 이더 리움 클라이언트의 일부 기능을 제공합니다. 서버에있는 제 3 자.

가장 인기있는 원격 클라이언트와 이들이 제공하는 기능을 살펴 보겠습니다.

모바일 (스마트 폰) 지갑
모든 모바일 지갑은 원격 클라이언트입니다. 스마트 폰에는 전체 이더 리움 클라이언트를 실행하기에 충분한 리소스가 없기 때문입니다. 라이트 클라이언트는 개발 중이며 이더 리움에 일반적으로 사용되지 않습니다. 패리티의 경우 라이트 클라이언트는 "실험용"으로 표시되며 --light 옵션으로 패리티를 실행하여 사용할 수 있습니다.

인기있는 모바일 지갑은 다음과 같습니다 (단지 예시로 나열합니다. 이는 지갑의 보안 또는 기능을 보증하거나 표시하지 않습니다).

Jaxx
Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash, 다양한 ERC20 토큰 및 기타 여러 통화를 지원하는 BIP-39 니모닉 시드를 기반으로하는 다중 통화 모바일 지갑입니다. Jaxx는 Android 및 iOS, 브라우저 플러그인 지갑 및 다양한 운영 체제 용 데스크톱 지갑으로 사용할 수 있습니다.

상태
다양한 토큰 및 인기있는 DApp을 지원하는 모바일 지갑 및 DApp 브라우저. iOS 및 Android에서 사용할 수 있습니다.

트러스트 월렛
Ethereum 및 Ethereum Classic은 물론 ERC20 및 ERC223 토큰을 지원하는 모바일 다중 통화 지갑입니다. 트러스트 월렛은 iOS 및 Android에서 사용할 수 있습니다.

암호 브라우저
이더 리움 앱 및 토큰과 통합 할 수있는 모든 기능을 갖춘 이더 리움 지원 모바일 DApp 브라우저 및 지갑입니다. iOS 및 Android에서 사용할 수 있습니다.

브라우저 지갑
Chrome 및 Firefox와 같은 웹 브라우저의 플러그인 또는 확장 기능으로 다양한 지갑 및 DApp 브라우저를 사용할 수 있습니다. 브라우저 내에서 실행되는 원격 클라이언트입니다.

더 인기있는 것 중 일부는 MetaMask, Jaxx, MyEtherWallet 및 MyCrypto입니다.

메타 마스크
MetaMask 도입, [intro_chapter]는 이다 브라우저 기반 월렛, RPC 클라이언트, 계약 및 기본 탐색기 융통성있게. Chrome, Firefox, Opera 및 Brave Browser에서 사용할 수 있습니다.

다른 브라우저 지갑과 달리 MetaMask는 브라우저 JavaScript 컨텍스트에 web3 인스턴스를 삽입하여 다양한 이더 리움 블록 체인 (메인 넷, Ropsten 테스트 넷, Kovan 테스트 넷, 로컬 RPC 노드 등)에 연결하는 RPC 클라이언트 역할을합니다. web3 인스턴스를 삽입하고 외부 RPC 서비스에 대한 게이트웨이 역할을하는 기능은 MetaMask를 개발자와 사용자 모두에게 매우 강력한 도구로 만듭니다. 예를 들어 MyEtherWallet 또는 MyCrypto와 결합하여 해당 도구에 대한 web3 공급자 및 RPC 게이트웨이 역할을 할 수 있습니다.

Jaxx
이전 섹션에서 모바일 지갑으로 소개 된 Jaxx 는 Chrome 및 Firefox 확장 프로그램과 데스크톱 지갑으로도 사용할 수 있습니다.

MyEtherWallet (MEW)
MyEtherWallet 은 다음을 제공하는 브라우저 기반 JavaScript 원격 클라이언트입니다.

Trezor 및 Ledger와 같은 인기있는 하드웨어 지갑에 연결

다른 클라이언트 (예 : MetaMask)에 의해 주입 된 web3 인스턴스에 연결할 수있는 web3 인터페이스

이더 리움 풀 클라이언트에 연결할 수있는 RPC 클라이언트

계약의 주소 및 ABI (애플리케이션 바이너리 인터페이스)가 주어지면 스마트 계약과 상호 작용할 수있는 기본 인터페이스

하드웨어 지갑과 유사하게 호환되는 Android 또는 iOS 장치를 사용하여 자금을 저장할 수있는 모바일 앱 MEWConnect.

JavaScript로 실행되는 소프트웨어 지갑

경고
MyEtherWallet 및 기타 브라우저 기반 JavaScript 지갑은 피싱의 빈번한 표적이기 때문에 매우주의해야합니다. 올바른 웹 URL에 액세스하려면 항상 검색 엔진이나 링크가 아닌 책갈피를 사용하십시오.

MyCrypto
2018 년 초, MyEtherWallet 프로젝트는 두 개의 독립적 인 개발 팀이 안내하는 두 개의 경쟁 구현으로 분할되었습니다. 오픈 소스 개발에서 호출되는 "포크"입니다. 두 프로젝트는 MyEtherWallet (원래 브랜딩)과 MyCrypto라고 합니다. MyCrypto는 MyEtherWallet과 거의 동일한 기능을 제공하지만 MEWConnect를 사용하는 대신 Parity Signer 모바일 앱에 대한 연결을 제공합니다. MEWConnect와 마찬가지로 Parity Signer는 전화에 키를 저장하고 하드웨어 지갑과 유사한 방식으로 MyCrypto와 인터페이스합니다.

미스트 (사용되지 않음)
Mist 는 Ethereum Foundation에서 구축 한 최초의 Ethereum 지원 브라우저였습니다. 여기에는 ERC20 토큰 표준을 처음 구현 한 브라우저 기반 지갑이 포함되어 있습니다 (ERC20의 작성자 인 Fabian Vogelsteller도 Mist의 주요 개발자였습니다). Mist는 또한 camelCase 체크섬 (EIP-55)을 도입 한 최초의 지갑입니다. 2019 년 3 월부터 Mist는 더 이상 사용되지 않으며 더 이상 사용해서는 안됩니다.

결론
이 장에서는 이더 리움 클라이언트를 살펴 보았습니다. 클라이언트를 다운로드, 설치 및 동기화하여 이더 리움 네트워크에 참여하고 자신의 컴퓨터에 블록 체인을 복제하여 시스템의 건강과 안정성에 기여했습니다.

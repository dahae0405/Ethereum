# Transactions

1. The Structure of a Transaction
2. The Transaction Nonce
  2.1. Keeping Track of Nonces
3. Transaction Gas
4. Transaction Recipient
5. Transaction Value and Data
6. Special Transaction: Contract Creation
7. Digital Signatures
8. The Signature Prefix Value (v) and Public Key Recovery
9. Separating Signing and Transmission (Offline Signing)
10. Transaction Propagation
11. Recording on the Blockchain
12. Multiple-Signature (Multisig) Transactions
13. Conclusions

##### INTRO
서문: ' 서문 '  
1장: ' 이더리움이란 무엇인가 '  
  ->  **분산 시스템**으로 작동 (  스마트 계약에 대한 액세스를 제어하는 ​​개인 키를 제어할 수 있고 제어 )  
  ->  **탈중앙화**된 세계 컴퓨터로서의 이더리움의 기능에 종속 ( 이더리움 블록체인 )  
  ->   
  ** 1장 용어 **  
  -> 자금에 대한 접근과 스마트 계약의 조합을 "계정" 또는 "지갑"  
  -> 그러나 기본 원칙으로서 하나의 개인 키가 하나의 "계정"과 동일
2장: ' 이더리움 기초 '  
  -> 지갑을 사용하는 방법, 트랜잭션을 생성하는 방법 및 기본 스마트 계약을 실행하는 방법  
  -> 1, 이더리움 블록체인는 월드 컴퓨터에서 작동.  
  -> 2. 외부 소유 계정(EOA) 및 계약  
      - MetaMask 지갑에서 생성한 계정 유형을 **외부 소유 계정 (EOA)** ( 외부 소유 계정은 **개인 키**가 있는 계정. 즉, 인 키가 있다는 것은 자금 또는 계약에 대한 **액세스를 제어한다**  
         는 의미 )  
      - **계약 계정** ( 계약 계정에는 간단한 EOA가 가질 수 없는 스마트 계약 코드가 있습니다. 계약 계정에는 개인 키가 없습니다. 대신 스마트 계약 코드의 논리에 의해 소유(및 제어)됩니다. 계약         계정생성 시 **이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램** )  
      - MetaMask vs 계약 계정 ( 계약에는 EOA와 마찬가지로 주소가 있습니다. 계약은 EOA와 마찬가지로 **이더를 보내고 받을 수도 있습니다.**  
        그러나 트랜잭션 대상이 **계약 주소인 경우** 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 해당 계약 이 EVM에서 실행 됩니다  
        계약 계정에는 개인 키가 없기 때문에 트랜잭션을 시작할 수 없습니다  
        **EOA만 트랜잭션을 시작할 수 있지만** **계약은 다른 계약을 호출하고 복잡한 실행 경로를 구축하여 트랜잭션에 반응 할 수 있습니다**  
        **일반적인 DApp 프로그래밍 패턴은 계약 A의 사용자 간에 공유 상태를 유지하기 위해 계약 A가 계약 B를 호출하도록 하는 것입니다.**  
        )   
          
  -> 3. 계약 컴파일 ( 컴파일러를 사용하여 Solidity 코드를 블록체인 자체의 **EVM에서 실행할 수 있도록 EVM 바이트 코드로 변환** )  
  -> 5. 블록체인에서 계약 생성  
      - 이제 **이더리움 블록체인에** **계약을 "등록"**  
      - **블록체인에 계약을 등록하려면 대상이 주소 0x00000000000000000000000000000000000000( 영 주소 라고도 함)인 특수 트랜잭션을 생성**  
      ( 이더리움 블록체인에 계약을 등록하고 싶다는 것을 알려주는 특별한 주소 )  
    
3장: ' 이더리움 클라이언트 '  
4장: ' 암호화 '  
5장: ' 지갑 '  
6장: ' 거래 '
7장: ' 스마트 계약과 견고성 '  
8장: ' 스마트 계약과 바이퍼 '  
9장: ' 스마트 계약 보안 '  
10장: ' 토큰 '  
11장: ' 오라클 '  
12장: ' 분산 애플리케이션(DApps) '  
13장: ' 이더리움 가상 머신 '  
14장: ' 합의 '  
  
##### 트렌젝션
- 블록체인
- 거래
- 
- 거래는 외부 소유 계정 (EOA)에서 생성되고 이더 리움 네트워크에 의해 전송되고 이더 리움 블록 체인에 기록 된 서명 된 메시지입니다.
-  트랜잭션을 보는 또 다른 방법은 트랜잭션이 상태 변경을 트리거하거나 계약이 EVM에서 실행되도록 할 수있는 유일한 것입니다.
-  이더 리움은 글로벌 싱글 톤 상태 머신이며 

## 1.The Structure of a Transaction
트랜잭션은 외부 소유 계정(EOA)에서 생성된 서명된 메시지로 이더리움 네트워크에서 전송되고 이더리움 블록체인에 기록됩니다. 이 기본 정의에는 놀랍고 매혹적인 세부 사항이 많이 숨겨져 있습니다. 트랜잭션을 보는 또 다른 방법은 트랜잭션이 상태 변경을 트리거하거나 EVM에서 계약이 실행되도록 할 수 있는 유일한 항목이라는 것입니다. 이더리움은 글로벌 싱글톤 상태 머신이며 트랜잭션은 상태 머신을 "틱"하게 만들어 상태를 변경합니다. 계약은 자체적으로 실행되지 않습니다. 이더리움은 자율적으로 실행되지 않습니다. 모든 것은 거래로 시작됩니다.

이 장에서는 트랜잭션을 분석하고 작동 방식을 보여주고 세부 사항을 검토합니다. 이 장의 대부분은 지갑 앱을 작성하고 있기 때문에 낮은 수준에서 자신의 거래를 관리하는 데 관심이 있는 사람들을 대상으로 합니다. 기존 지갑 응용 프로그램을 사용하는 데 만족한다면 이에 대해 걱정할 필요가 없지만 세부 사항이 흥미로울 수 있습니다!

## 2.The Transaction Nonce
먼저 이더리움 네트워크에서 직렬화되어 전송되는 트랜잭션의 기본 구조를 살펴보겠습니다. 직렬화된 트랜잭션을 수신하는 각 클라이언트와 애플리케이션은 자체 내부 데이터 구조를 사용하여 메모리에 저장합니다. 아마도 네트워크 직렬화된 트랜잭션 자체에는 존재하지 않는 메타데이터로 장식될 것입니다. 네트워크 직렬화는 트랜잭션의 유일한 표준 형식입니다.

트랜잭션은 다음 데이터를 포함하는 직렬화된 이진 메시지입니다.

목하
메시지 재생을 방지하는 데 사용되는 발신 EOA에서 발행한 시퀀스 번호

가스 가격
발신자가 각 가스 단위에 대해 지불할 의향이 있는 에테르의 양(wei)

가스 제한
발신자가 이 거래를 위해 구매하고자 하는 최대 가스량

받는 사람
대상 이더리움 주소

값
목적지로 보낼 이더(wei)의 양

데이터
가변 길이 이진 데이터 페이로드

v,r,s
발신 EOA의 ECDSA 디지털 서명의 세 가지 구성요소

트랜잭션 메시지의 구조는 이더리움에서 단순하고 완벽한 바이트 데이터 직렬화를 위해 특별히 생성된 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 직렬화됩니다. 이더리움의 모든 숫자는 길이가 8비트의 배수인 빅엔디안 정수로 인코딩됩니다.

필드 레이블(to, gas limit 등)은 명확성을 위해 여기에 표시되지만 RLP로 인코딩된 필드 값을 포함하는 트랜잭션 직렬 데이터의 일부가 아닙니다. 일반적으로 RLP에는 필드 구분 기호나 레이블이 포함되지 않습니다. RLP의 길이 접두사는 각 필드의 길이를 식별하는 데 사용됩니다. 정의된 길이를 초과하는 모든 것은 구조의 다음 필드에 속합니다.

이것이 전송된 실제 트랜잭션 구조이지만 대부분의 내부 표현과 사용자 인터페이스 시각화는 트랜잭션 또는 블록체인에서 파생된 추가 정보로 이를 장식합니다.

예를 들어, 발신자 EOA를 식별하는 주소에 "보낸 사람" 데이터가 없음을 알 수 있습니다. EOA의 공개 키는 ECDSA 서명의 v,r, 구성 요소에서 파생될 수 있기 때문입니다. 주소는 차례로 공개 키에서 파생될 수 있습니다. "from" 필드가 표시된 트랜잭션을 보면 트랜잭션을 시각화하는 데 사용되는 소프트웨어에서 추가한 것입니다. 클라이언트 소프트웨어가 트랜잭션에 자주 추가하는 기타 메타데이터에는 블록 번호(마이닝되어 블록체인에 포함된 후)와 트랜잭션 ID(계산된 해시)가 포함됩니다. 다시 말하지만, 이 데이터는 트랜잭션에서 파생되며 트랜잭션 메시지 자체의 일부를 구성하지 않습니다. 

트랜잭션 Nonce
nonce는 트랜잭션의 가장 중요하고 가장 이해하기 어려운 구성 요소 중 하나입니다. Yellow Paper( [참조] 참조 ) 의 정의는 다음 과 같습니다.

nonce: 이 주소에서 보낸 트랜잭션 수와 동일한 스칼라 값 또는 관련 코드가 있는 계정의 경우 이 계정에서 만든 계약 생성 수입니다.

엄밀히 말하면 nonce는 발신 주소의 속성입니다. 즉, 보내는 주소의 컨텍스트에서만 의미가 있습니다. 그러나 nonce는 블록체인에서 계정 상태의 일부로 명시적으로 저장되지 않습니다. 대신 주소에서 발생한 확인된 트랜잭션 수를 계산하여 동적으로 계산됩니다.

트랜잭션 계산 nonce의 존재가 중요한 두 가지 시나리오가 있습니다. 생성 순서에 포함되는 트랜잭션의 사용성 기능과 트랜잭션 중복 방지의 중요한 기능입니다. 각각에 대한 예시 시나리오를 살펴보겠습니다.

두 가지 거래를 하고 싶다고 상상해 보십시오. 당신은 6 이더를 지불해야 하는 중요한 지불금이 있고 또 8 이더를 지불해야 합니다. 6-ether 트랜잭션이 더 중요하기 때문에 먼저 서명하고 브로드캐스트한 다음 두 번째 8-ether 트랜잭션에 서명하고 브로드캐스트합니다. 슬프게도 귀하는 귀하의 계정에 10개의 이더만 포함되어 있다는 사실을 간과하여 네트워크에서 두 트랜잭션을 모두 수락할 수 없습니다. 둘 중 하나는 실패합니다. 더 중요한 6-ether를 먼저 보냈기 때문에 당연히 하나는 통과하고 8-ether는 거부될 것으로 예상합니다. 그러나 이더리움과 같은 탈중앙화 시스템에서 노드는 두 가지 순서로 트랜잭션을 수신할 수 있습니다. 특정 노드가 한 트랜잭션이 다른 노드보다 먼저 전파된다는 보장은 없습니다. 이와 같이, 일부 노드는 6-ether 트랜잭션을 먼저 수신하고 다른 노드는 8-ether 트랜잭션을 먼저 수신하는 경우가 거의 확실합니다. nonce가 없으면 어느 쪽이 수락되고 어느 쪽이 거부되는지가 무작위입니다. 그러나 nonce가 포함된 상태에서 보낸 첫 번째 트랜잭션은 nonce가 3인 반면 8-ether 트랜잭션은 다음 nonce 값(즉, 4)을 갖습니다. 따라서 해당 트랜잭션은 먼저 수신되더라도 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴! 4). 따라서 해당 트랜잭션은 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴! 4). 따라서 해당 트랜잭션은 먼저 수신되더라도 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴!

이제 100 ether가 있는 계정이 있다고 상상해보십시오. 환상적이야! 당신이 정말로 사고 싶은 맥거핀 위젯에 대해 이더로 지불할 수 있는 사람을 온라인에서 찾을 수 있습니다. 당신은 그들에게 2개의 ether를 보내고 그들은 당신에게 mcguffin-widget을 보냅니다. 아름다운. 2-ether 지불을 하기 위해, 당신은 2-ether를 당신의 계정에서 그들의 계정으로 보내는 거래에 서명했고, 그것을 Ethereum 네트워크에 브로드캐스트하여 검증하고 블록체인에 포함시켰습니다. 이제 트랜잭션에 nonce 값이 없으면 동일한 주소로 2 ether를 두 번째로 보내는 두 번째 트랜잭션은 첫 번째 트랜잭션과 정확히 동일하게 보입니다. 이는 이더리움 네트워크에서 거래를 보는 사람(수취인 또는 적을 포함한 모든 사람을 의미함)이 "재생"할 수 있음을 의미합니다. 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 것만으로 모든 이더가 사라질 때까지 트랜잭션을 계속해서 반복합니다. 그러나 트랜잭션 데이터에 포함된 nonce 값으로,동일한 수취인 주소로 동일한 양의 이더를 여러 번 보내는 경우에도 모든 단일 트랜잭션은 고유 합니다. 따라서 트랜잭션의 일부로 nonce를 증가시키면 다른 사람이 귀하가 지불한 지불을 "중복"하는 것이 불가능합니다.

요약하자면, 비트코인 프로토콜의 "Unspent Transaction Output"(UTXO) 메커니즘과 달리 nonce의 사용은 실제로 계정 기반 프로토콜에 필수적이라는 점에 유의하는 것이 중요 합니다.

논스 추적하기
실용적인 측면에서 nonce는 계정에서 발생한 확인된 (즉, 온체인) 트랜잭션 수의 최신 카운트입니다 . nonce가 무엇인지 알아내기 위해 예를 들어 web3 인터페이스를 통해 블록체인을 조사할 수 있습니다. Ropsten testnet의 Geth(또는 선호하는 web3 인터페이스)에서 JavaScript 콘솔을 열고 다음을 입력합니다.

> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
팁
nonce는 0부터 시작하는 카운터로, 첫 번째 트랜잭션에 nonce 0이 있음을 의미합니다. 이 예에서 트랜잭션 수는 40이며, 이는 nonce 0에서 39까지 본 것을 의미합니다. 다음 트랜잭션의 nonce는 40이어야 합니다.

지갑은 관리하는 각 주소의 임시 항목을 추적합니다. 단일 지점에서만 트랜잭션을 시작하는 한 그렇게 하는 것은 매우 간단합니다. 자신의 지갑 소프트웨어나 트랜잭션을 발생시키는 다른 응용 프로그램을 작성한다고 가정해 보겠습니다. 넌스를 어떻게 추적합니까?

새 트랜잭션을 생성할 때 시퀀스의 다음 nonce를 할당합니다. 단, 확정될 때까지는 getTransactionCount총계에 합산 되지 않습니다 .

경고
getTransactionCount보류 중인 트랜잭션을 계산 하는 기능을 사용할 때 몇 개의 트랜잭션을 연속으로 보낼 경우 몇 가지 문제가 발생할 수 있으므로 주의하십시오 .

예를 살펴보겠습니다.

> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
40
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
팁
Geth의 자바스크립트 콘솔에서 이러한 코드 예제를 직접 재생성하려는 경우 web3.utils.toWei() 대신 web3.toWei()를 사용해야 합니다. Geth는 이전 버전의 web3 라이브러리를 사용하기 때문입니다.

보시다시피, 우리가 보낸 첫 번째 트랜잭션은 트랜잭션 수를 41로 늘려 보류 중인 트랜잭션을 보여줍니다. 그러나 우리가 3개의 트랜잭션을 더 빠르게 연속으로 보냈을 때 getTransactionCount호출은 그것들을 계산하지 않았습니다. mempool에 3개의 보류 중인 항목이 있을 것으로 예상할 수 있지만 1개만 계산되었습니다. 네트워크 통신이 안정될 때까지 몇 초를 기다리면 getTransactionCount호출에서 예상 번호를 반환합니다. 그러나 그 동안에는 하나 이상의 트랜잭션이 보류 중이지만 도움이 되지 않을 수 있습니다.

트랜잭션을 구성하는 애플리케이션을 빌드할 때 getTransactionCount보류 중인 트랜잭션 에 의존할 수 없습니다 . 보류 및 확인 횟수가 동일할 때만(모든 미결 트랜잭션이 확인됨) getTransactionCountnonce 카운터를 시작하기 위해 의 출력을 신뢰할 수 있습니다 . 그런 다음 각 트랜잭션이 확인될 때까지 애플리케이션의 nonce를 추적합니다.

Parity의 JSON RPC 인터페이스는 parity_nextNonce트랜잭션에서 사용해야 하는 다음 nonce를 반환하는 기능을 제공합니다 . 이 parity_nextNonce함수는 확인하지 않고 여러 트랜잭션을 빠르게 연속적으로 구성하더라도 nonce를 올바르게 계산합니다.

$ curl --data '{"메소드":"parity_nextNonce", \
  "매개변수":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "콘텐츠 유형: 애플리케이션/json" -X POST \
  로컬 호스트:8545

{"jsonrpc":"2.0","결과":"0x32","id":1}
팁
Parity에는 JSON RPC 인터페이스에 액세스하기 위한 웹 콘솔이 있지만 여기서는 명령줄 HTTP 클라이언트를 사용하여 액세스합니다.

### 2.1. Keeping Track of Nonces

## 3. Transaction Gas

## 4. Transaction Recipient

## 5. Transaction Value and Data

## 6. Special Transaction: Contract Creation

## 7. Digital Signatures

## 8. The Signature Prefix Value (v) and Public Key Recovery

## 9. Separating Signing and Transmission (Offline Signing)

## 10. Transaction Propagation

## 11. Recording on the Blockchain

## 12. Multiple-Signature (Multisig) Transactions

## 13. Conclusions

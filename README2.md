# Transactions

1. The Structure of a Transaction
2. The Transaction Nonce
  2.1. Keeping Track of Nonces
3. Transaction Gas
4. Transaction Recipient
5. Transaction Value and Data
6. Special Transaction: Contract Creation
7. Digital Signatures
8. The Signature Prefix Value (v) and Public Key Recovery
9. Separating Signing and Transmission (Offline Signing)
10. Transaction Propagation
11. Recording on the Blockchain
12. Multiple-Signature (Multisig) Transactions
13. Conclusions

##### INTRO
서문: ' 서문 '  
1장: ' 이더리움이란 무엇인가 '  
  ->  **분산 시스템**으로 작동 (  스마트 계약에 대한 액세스를 제어하는 ​​개인 키를 제어할 수 있고 제어 )  
  ->  **탈중앙화**된 세계 컴퓨터로서의 이더리움의 기능에 종속 ( 이더리움 블록체인 )  
  ->   
  ** 1장 용어 **  
  -> 자금에 대한 접근과 스마트 계약의 조합을 "계정" 또는 "지갑"   
  -> 그러나 기본 원칙으로서 하나의 개인 키가 하나의 "계정"과 동일  
2장: ' 이더리움 기초 '  
  -> 지갑을 사용하는 방법, 트랜잭션을 생성하는 방법 및 기본 스마트 계약을 실행하는 방법  
  -> 1, 이더리움 블록체인는 월드 컴퓨터에서 작동.  
  -> 2. 외부 소유 계정(EOA) 및 계약  
      - MetaMask 지갑에서 생성한 계정 유형을 **외부 소유 계정 (EOA)** ( 외부 소유 계정은 **개인 키**가 있는 계정. 즉, 인 키가 있다는 것은 자금 또는 계약에 대한 **액세스를 제어한다**  
         는 의미 )  
      - **계약 계정** ( 계약 계정에는 간단한 EOA가 가질 수 없는 스마트 계약 코드가 있습니다. 계약 계정에는 개인 키가 없습니다. 대신 스마트 계약 코드의 논리에 의해 소유(및 제어)됩니다. 계약         계정생성 시 **이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램** )  
      - MetaMask vs 계약 계정 ( 계약에는 EOA와 마찬가지로 주소가 있습니다. 계약은 EOA와 마찬가지로 **이더를 보내고 받을 수도 있습니다.**  
        그러나 트랜잭션 대상이 **계약 주소인 경우** 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 해당 계약 이 EVM에서 실행 됩니다  
        계약 계정에는 개인 키가 없기 때문에 트랜잭션을 시작할 수 없습니다  
        **EOA만 트랜잭션을 시작할 수 있지만** **계약은 다른 계약을 호출하고 복잡한 실행 경로를 구축하여 트랜잭션에 반응 할 수 있습니다**  
        **일반적인 DApp 프로그래밍 패턴은 계약 A의 사용자 간에 공유 상태를 유지하기 위해 계약 A가 계약 B를 호출하도록 하는 것입니다.**  
        )   
          
  -> 3. 계약 컴파일 ( 컴파일러를 사용하여 Solidity 코드를 블록체인 자체의 **EVM에서 실행할 수 있도록 EVM 바이트 코드로 변환** )  
  -> 5. 블록체인에서 계약 생성  
      - 이제 **이더리움 블록체인에** **계약을 "등록"**  
      - **블록체인에 계약을 등록하려면 대상이 주소 0x00000000000000000000000000000000000000( 영 주소 라고도 함)인 특수 트랜잭션을 생성**  
      ( 이더리움 블록체인에 계약을 등록하고 싶다는 것을 알려주는 특별한 주소 )  
    
3장: ' 이더리움 클라이언트 '  
4장: ' 암호화 '  
5장: ' 지갑 '  
6장: ' 거래 '
7장: ' 스마트 계약과 견고성 '  
8장: ' 스마트 계약과 바이퍼 '  
9장: ' 스마트 계약 보안 '  
10장: ' 토큰 '  
11장: ' 오라클 '  
12장: ' 분산 애플리케이션(DApps) '  
13장: ' 이더리움 가상 머신 '  
14장: ' 합의 '  
  
##### 트렌젝션
- 블록체인
- 거래
- 
- 거래는 외부 소유 계정 (EOA)에서 생성되고 이더 리움 네트워크에 의해 전송되고 이더 리움 블록 체인에 기록 된 서명 된 메시지입니다.
-  트랜잭션을 보는 또 다른 방법은 트랜잭션이 상태 변경을 트리거하거나 계약이 EVM에서 실행되도록 할 수있는 유일한 것입니다.
-  이더 리움은 글로벌 싱글 톤 상태 머신이며 

## 1.The Structure of a Transaction
트랜잭션은 외부 소유 계정(EOA)에서 생성된 서명된 메시지로 이더리움 네트워크에서 전송되고 이더리움 블록체인에 기록됩니다. 이 기본 정의에는 놀랍고 매혹적인 세부 사항이 많이 숨겨져 있습니다. 트랜잭션을 보는 또 다른 방법은 트랜잭션이 상태 변경을 트리거하거나 EVM에서 계약이 실행되도록 할 수 있는 유일한 항목이라는 것입니다. 이더리움은 글로벌 싱글톤 상태 머신이며 트랜잭션은 상태 머신을 "틱"하게 만들어 상태를 변경합니다. 계약은 자체적으로 실행되지 않습니다. 이더리움은 자율적으로 실행되지 않습니다. 모든 것은 거래로 시작됩니다.

이 장에서는 트랜잭션을 분석하고 작동 방식을 보여주고 세부 사항을 검토합니다. 이 장의 대부분은 지갑 앱을 작성하고 있기 때문에 낮은 수준에서 자신의 거래를 관리하는 데 관심이 있는 사람들을 대상으로 합니다. 기존 지갑 응용 프로그램을 사용하는 데 만족한다면 이에 대해 걱정할 필요가 없지만 세부 사항이 흥미로울 수 있습니다!

## 2.The Transaction Nonce
먼저 이더리움 네트워크에서 직렬화되어 전송되는 트랜잭션의 기본 구조를 살펴보겠습니다. 직렬화된 트랜잭션을 수신하는 각 클라이언트와 애플리케이션은 자체 내부 데이터 구조를 사용하여 메모리에 저장합니다. 아마도 네트워크 직렬화된 트랜잭션 자체에는 존재하지 않는 메타데이터로 장식될 것입니다. 네트워크 직렬화는 트랜잭션의 유일한 표준 형식입니다.

트랜잭션은 다음 데이터를 포함하는 직렬화된 이진 메시지입니다.

목하
메시지 재생을 방지하는 데 사용되는 발신 EOA에서 발행한 시퀀스 번호

가스 가격
발신자가 각 가스 단위에 대해 지불할 의향이 있는 에테르의 양(wei)

가스 제한
발신자가 이 거래를 위해 구매하고자 하는 최대 가스량

받는 사람
대상 이더리움 주소

값
목적지로 보낼 이더(wei)의 양

데이터
가변 길이 이진 데이터 페이로드

v,r,s
발신 EOA의 ECDSA 디지털 서명의 세 가지 구성요소

트랜잭션 메시지의 구조는 이더리움에서 단순하고 완벽한 바이트 데이터 직렬화를 위해 특별히 생성된 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 직렬화됩니다. 이더리움의 모든 숫자는 길이가 8비트의 배수인 빅엔디안 정수로 인코딩됩니다.

필드 레이블(to, gas limit 등)은 명확성을 위해 여기에 표시되지만 RLP로 인코딩된 필드 값을 포함하는 트랜잭션 직렬 데이터의 일부가 아닙니다. 일반적으로 RLP에는 필드 구분 기호나 레이블이 포함되지 않습니다. RLP의 길이 접두사는 각 필드의 길이를 식별하는 데 사용됩니다. 정의된 길이를 초과하는 모든 것은 구조의 다음 필드에 속합니다.

이것이 전송된 실제 트랜잭션 구조이지만 대부분의 내부 표현과 사용자 인터페이스 시각화는 트랜잭션 또는 블록체인에서 파생된 추가 정보로 이를 장식합니다.

예를 들어, 발신자 EOA를 식별하는 주소에 "보낸 사람" 데이터가 없음을 알 수 있습니다. EOA의 공개 키는 ECDSA 서명의 v,r, 구성 요소에서 파생될 수 있기 때문입니다. 주소는 차례로 공개 키에서 파생될 수 있습니다. "from" 필드가 표시된 트랜잭션을 보면 트랜잭션을 시각화하는 데 사용되는 소프트웨어에서 추가한 것입니다. 클라이언트 소프트웨어가 트랜잭션에 자주 추가하는 기타 메타데이터에는 블록 번호(마이닝되어 블록체인에 포함된 후)와 트랜잭션 ID(계산된 해시)가 포함됩니다. 다시 말하지만, 이 데이터는 트랜잭션에서 파생되며 트랜잭션 메시지 자체의 일부를 구성하지 않습니다. 

#### 트랜잭션 Nonce
nonce는 트랜잭션의 가장 중요하고 가장 이해하기 어려운 구성 요소 중 하나입니다. Yellow Paper( [참조] 참조 ) 의 정의는 다음 과 같습니다.

nonce: 이 주소에서 보낸 트랜잭션 수와 동일한 스칼라 값 또는 관련 코드가 있는 계정의 경우 이 계정에서 만든 계약 생성 수입니다.

엄밀히 말하면 nonce는 발신 주소의 속성입니다. 즉, 보내는 주소의 컨텍스트에서만 의미가 있습니다. 그러나 nonce는 블록체인에서 계정 상태의 일부로 명시적으로 저장되지 않습니다. 대신 주소에서 발생한 확인된 트랜잭션 수를 계산하여 동적으로 계산됩니다.

트랜잭션 계산 nonce의 존재가 중요한 두 가지 시나리오가 있습니다. 생성 순서에 포함되는 트랜잭션의 사용성 기능과 트랜잭션 중복 방지의 중요한 기능입니다. 각각에 대한 예시 시나리오를 살펴보겠습니다.

두 가지 거래를 하고 싶다고 상상해 보십시오. 당신은 6 이더를 지불해야 하는 중요한 지불금이 있고 또 8 이더를 지불해야 합니다. 6-ether 트랜잭션이 더 중요하기 때문에 먼저 서명하고 브로드캐스트한 다음 두 번째 8-ether 트랜잭션에 서명하고 브로드캐스트합니다. 슬프게도 귀하는 귀하의 계정에 10개의 이더만 포함되어 있다는 사실을 간과하여 네트워크에서 두 트랜잭션을 모두 수락할 수 없습니다. 둘 중 하나는 실패합니다. 더 중요한 6-ether를 먼저 보냈기 때문에 당연히 하나는 통과하고 8-ether는 거부될 것으로 예상합니다. 그러나 이더리움과 같은 탈중앙화 시스템에서 노드는 두 가지 순서로 트랜잭션을 수신할 수 있습니다. 특정 노드가 한 트랜잭션이 다른 노드보다 먼저 전파된다는 보장은 없습니다. 이와 같이, 일부 노드는 6-ether 트랜잭션을 먼저 수신하고 다른 노드는 8-ether 트랜잭션을 먼저 수신하는 경우가 거의 확실합니다. nonce가 없으면 어느 쪽이 수락되고 어느 쪽이 거부되는지가 무작위입니다. 그러나 nonce가 포함된 상태에서 보낸 첫 번째 트랜잭션은 nonce가 3인 반면 8-ether 트랜잭션은 다음 nonce 값(즉, 4)을 갖습니다. 따라서 해당 트랜잭션은 먼저 수신되더라도 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴! 4). 따라서 해당 트랜잭션은 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴! 4). 따라서 해당 트랜잭션은 먼저 수신되더라도 0에서 3까지의 nonce가 있는 트랜잭션이 처리될 때까지 무시됩니다. 휴!

이제 100 ether가 있는 계정이 있다고 상상해보십시오. 환상적이야! 당신이 정말로 사고 싶은 맥거핀 위젯에 대해 이더로 지불할 수 있는 사람을 온라인에서 찾을 수 있습니다. 당신은 그들에게 2개의 ether를 보내고 그들은 당신에게 mcguffin-widget을 보냅니다. 아름다운. 2-ether 지불을 하기 위해, 당신은 2-ether를 당신의 계정에서 그들의 계정으로 보내는 거래에 서명했고, 그것을 Ethereum 네트워크에 브로드캐스트하여 검증하고 블록체인에 포함시켰습니다. 이제 트랜잭션에 nonce 값이 없으면 동일한 주소로 2 ether를 두 번째로 보내는 두 번째 트랜잭션은 첫 번째 트랜잭션과 정확히 동일하게 보입니다. 이는 이더리움 네트워크에서 거래를 보는 사람(수취인 또는 적을 포함한 모든 사람을 의미함)이 "재생"할 수 있음을 의미합니다. 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 것만으로 모든 이더가 사라질 때까지 트랜잭션을 계속해서 반복합니다. 그러나 트랜잭션 데이터에 포함된 nonce 값으로,동일한 수취인 주소로 동일한 양의 이더를 여러 번 보내는 경우에도 모든 단일 트랜잭션은 고유 합니다. 따라서 트랜잭션의 일부로 nonce를 증가시키면 다른 사람이 귀하가 지불한 지불을 "중복"하는 것이 불가능합니다.

요약하자면, 비트코인 프로토콜의 "Unspent Transaction Output"(UTXO) 메커니즘과 달리 nonce의 사용은 실제로 계정 기반 프로토콜에 필수적이라는 점에 유의하는 것이 중요 합니다.

#### 논스 추적하기
실용적인 측면에서 nonce는 계정에서 발생한 확인된 (즉, 온체인) 트랜잭션 수의 최신 카운트입니다 . nonce가 무엇인지 알아내기 위해 예를 들어 web3 인터페이스를 통해 블록체인을 조사할 수 있습니다. Ropsten testnet의 Geth(또는 선호하는 web3 인터페이스)에서 JavaScript 콘솔을 열고 다음을 입력합니다.

> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
팁
nonce는 0부터 시작하는 카운터로, 첫 번째 트랜잭션에 nonce 0이 있음을 의미합니다. 이 예에서 트랜잭션 수는 40이며, 이는 nonce 0에서 39까지 본 것을 의미합니다. 다음 트랜잭션의 nonce는 40이어야 합니다.

지갑은 관리하는 각 주소의 임시 항목을 추적합니다. 단일 지점에서만 트랜잭션을 시작하는 한 그렇게 하는 것은 매우 간단합니다. 자신의 지갑 소프트웨어나 트랜잭션을 발생시키는 다른 응용 프로그램을 작성한다고 가정해 보겠습니다. 넌스를 어떻게 추적합니까?

새 트랜잭션을 생성할 때 시퀀스의 다음 nonce를 할당합니다. 단, 확정될 때까지는 getTransactionCount총계에 합산 되지 않습니다 .

경고
getTransactionCount보류 중인 트랜잭션을 계산 하는 기능을 사용할 때 몇 개의 트랜잭션을 연속으로 보낼 경우 몇 가지 문제가 발생할 수 있으므로 주의하십시오 .

예를 살펴보겠습니다.

> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
40
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", 값: web3.utils.toWei(0.01, "ether")}); 
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"보류 중")
41
팁
Geth의 자바스크립트 콘솔에서 이러한 코드 예제를 직접 재생성하려는 경우 web3.utils.toWei() 대신 web3.toWei()를 사용해야 합니다. Geth는 이전 버전의 web3 라이브러리를 사용하기 때문입니다.

보시다시피, 우리가 보낸 첫 번째 트랜잭션은 트랜잭션 수를 41로 늘려 보류 중인 트랜잭션을 보여줍니다. 그러나 우리가 3개의 트랜잭션을 더 빠르게 연속으로 보냈을 때 getTransactionCount호출은 그것들을 계산하지 않았습니다. mempool에 3개의 보류 중인 항목이 있을 것으로 예상할 수 있지만 1개만 계산되었습니다. 네트워크 통신이 안정될 때까지 몇 초를 기다리면 getTransactionCount호출에서 예상 번호를 반환합니다. 그러나 그 동안에는 하나 이상의 트랜잭션이 보류 중이지만 도움이 되지 않을 수 있습니다.

트랜잭션을 구성하는 애플리케이션을 빌드할 때 getTransactionCount보류 중인 트랜잭션 에 의존할 수 없습니다 . 보류 및 확인 횟수가 동일할 때만(모든 미결 트랜잭션이 확인됨) getTransactionCountnonce 카운터를 시작하기 위해 의 출력을 신뢰할 수 있습니다 . 그런 다음 각 트랜잭션이 확인될 때까지 애플리케이션의 nonce를 추적합니다.

Parity의 JSON RPC 인터페이스는 parity_nextNonce트랜잭션에서 사용해야 하는 다음 nonce를 반환하는 기능을 제공합니다 . 이 parity_nextNonce함수는 확인하지 않고 여러 트랜잭션을 빠르게 연속적으로 구성하더라도 nonce를 올바르게 계산합니다.

$ curl --data '{"메소드":"parity_nextNonce", \
  "매개변수":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "콘텐츠 유형: 애플리케이션/json" -X POST \
  로컬 호스트:8545

{"jsonrpc":"2.0","결과":"0x32","id":1}
팁
Parity에는 JSON RPC 인터페이스에 액세스하기 위한 웹 콘솔이 있지만 여기서는 명령줄 HTTP 클라이언트를 사용하여 액세스합니다.

#### Nonce의 공백, 중복 Nonce 및 확인
### 2.1. Keeping Track of Nonces
프로그래밍 방식으로 트랜잭션을 생성하는 경우, 특히 여러 독립 프로세스에서 동시에 수행하는 경우 임시 항목을 추적하는 것이 중요합니다 .

이더리움 네트워크는 nonce를 기반으로 트랜잭션을 순차적으로 처리합니다. 즉, nonce가 0인 트랜잭션을 전송한 다음 nonce가 2인 트랜잭션을 전송하면 두 번째 트랜잭션은 블록에 포함되지 않습니다. 이더리움 네트워크는 누락된 nonce가 나타날 때까지 기다리는 동안 mempool에 저장됩니다. 모든 노드는 누락된 nonce가 단순히 지연되었고 nonce 2가 있는 트랜잭션이 순서 없이 수신되었다고 가정합니다.

그런 다음 nonce 1이 누락된 트랜잭션을 전송하면 두 트랜잭션(nonce 1 및 2)이 모두 처리되고 포함됩니다(물론 유효한 경우). 간격을 채우면 네트워크가 mempool에 보관된 순서가 잘못된 트랜잭션을 마이닝할 수 있습니다.

이것이 의미하는 바는 순서대로 여러 트랜잭션을 생성하고 그 중 하나가 공식적으로 블록에 포함되지 않으면 모든 후속 트랜잭션이 "고정"되어 누락된 nonce를 기다리는 것입니다. 트랜잭션은 유효하지 않거나 가스가 충분하지 않기 때문에 nonce 시퀀스에 의도하지 않은 "갭"을 만들 수 있습니다. 다시 움직이려면 nonce가 누락된 유효한 트랜잭션을 전송해야 합니다. "누락된" nonce가 있는 트랜잭션이 네트워크에 의해 확인되면 후속 nonce가 있는 모든 브로드캐스트 트랜잭션이 점차적으로 유효해집니다. 거래를 "회수"하는 것은 불가능합니다!

반면에 nonce는 동일하지만 받는 사람이나 값이 다른 두 트랜잭션을 전송하는 것과 같이 실수로 nonce를 복제하는 경우 그 중 하나는 확인되고 하나는 거부됩니다. 어느 것이 확인되는지는 그것을 수신하는 첫 번째 검증 노드에 도달하는 순서에 따라 결정됩니다. 즉, 상당히 무작위입니다.

보시다시피 nonce를 추적하는 것이 필요하며 애플리케이션이 해당 프로세스를 올바르게 관리하지 않으면 문제가 발생합니다. 불행히도 다음 섹션에서 볼 수 있듯이 동시에 이 작업을 수행하려고 하면 상황이 훨씬 더 어려워집니다.

동시성, 트랜잭션 시작 및 논스
동시성은 컴퓨터 과학의 복잡한 측면이며 특히 Ethereum 과 같은 분산 및 분산 실시간 시스템에서 예기치 않게 발생 합니다.

간단히 말해서 동시성은 여러 독립 시스템에서 동시에 계산하는 경우입니다. 이들은 동일한 프로그램(예: 멀티스레딩), 동일한 CPU(예: 멀티프로세싱) 또는 다른 컴퓨터(예: 분산 시스템 )에 있을 수 있습니다. 정의에 따르면 이더리움은 작업(노드, 클라이언트, DApp)의 동시성을 허용하지만 합의를 통해 싱글톤 상태를 적용하는 시스템입니다.

이제 동일한 주소에서 트랜잭션을 생성하는 여러 개의 독립적인 지갑 애플리케이션이 있다고 상상해 보십시오. 이러한 상황의 한 예로 거래소의 핫 월렛(키가 온라인에 저장되지 않는 콜드 월렛과 대조적으로 키가 온라인에 저장된 지갑)에서 인출을 처리하는 거래소가 있습니다. 이상적으로는 하나 이상의 컴퓨터에서 인출을 처리하여 병목 현상이나 단일 실패 지점이 되지 않도록 하는 것이 좋습니다. 그러나 출금을 생성하는 컴퓨터가 두 대 이상 있으면 몇 가지 어려운 동시성 문제가 발생하기 때문에 이는 곧 문제가 됩니다. 동일한 핫월렛 계정에서 여러 컴퓨터가 트랜잭션을 생성, 서명 및 브로드캐스팅하는 방법은 무엇입니까?

단일 컴퓨터를 사용하여 트랜잭션에 서명하는 컴퓨터에 선착순으로 임시 항목을 할당할 수 있습니다. 그러나 이 컴퓨터는 이제 단일 실패 지점입니다. 설상가상으로 여러 nonce가 할당되고 그 중 하나가 사용되지 않으면(해당 nonce로 트랜잭션을 처리하는 컴퓨터의 오류로 인해) 모든 후속 트랜잭션이 중단됩니다.

또 다른 접근 방식은 트랜잭션을 생성하지만 트랜잭션에 nonce를 할당하지 않는 것입니다(따라서 서명되지 않은 상태로 두십시오. nonce는 트랜잭션 데이터의 필수적인 부분이므로 트랜잭션을 인증하는 디지털 서명에 포함되어야 함을 기억하십시오). . 그런 다음 서명하고 임시 항목을 추적하는 단일 노드에 대기열을 지정할 수 있습니다. 다시 말하지만, 이것은 프로세스의 질식 지점이 될 것입니다. nonce의 서명 및 추적은 로드 시 혼잡할 가능성이 있는 작업의 일부인 반면 서명되지 않은 트랜잭션의 생성은 실제로 수행하지 않는 부분입니다. 병렬화해야 합니다. 동시성은 어느 정도 있지만 프로세스의 중요한 부분에서는 부족합니다.

결국, 이러한 동시성 문제는 독립적인 프로세스에서 계좌 잔고 및 거래 확인을 추적하는 어려움 외에도 대부분의 구현이 동시성을 피하고 거래소에서 모든 출금 거래를 처리하는 단일 프로세스와 같은 병목 현상을 만드는 방향으로 대부분의 구현을 강요합니다. 출금을 위해 완전히 독립적으로 작동할 수 있고 간헐적으로 재조정되기만 하면 되는 핫월렛입니다.


## 3. Transaction Gas
거래 수신자는 받는 사람 필드에 지정됩니다. 여기에는 20바이트 이더리움 주소가 포함됩니다. 주소는 EOA 또는 계약 주소일 수 있습니다.

Ethereum은 이 필드를 더 이상 검증하지 않습니다. 모든 20바이트 값이 유효한 것으로 간주됩니다. 20바이트 값이 해당 개인 키가 없거나 해당 계약이 없는 주소에 해당하는 경우 트랜잭션은 여전히 ​​유효합니다. Ethereum은 주소가 존재하는 공개 키(따라서 개인 키)에서 올바르게 파생되었는지 여부를 알 수 있는 방법이 없습니다.

경고
이더리움 프로토콜은 거래에서 수신자 주소를 확인하지 않습니다. 해당 개인 키나 계약이 없는 주소로 보낼 수 있으므로 이더를 "소각"하여 영원히 사용할 수 없게 만듭니다. 유효성 검사는 사용자 인터페이스 수준에서 수행해야 합니다.

잘못된 주소로 트랜잭션을 보내는 것은 아마 것 화상 이, (unspendable) 영원히 접근 할 수없는 대부분의 주소가 알려진 개인 키 때문에 더 서명을 보내고 생성되지 수를 가지고 있지 않기 때문에 렌더링, 에테르하여 전송합니다. 주소 유효성 검사는 사용자 인터페이스 수준에서 발생한다고 가정합니다( [EIP55] 참조 ). 실제로 이더를 소각하는 데에는 여러 가지 타당한 이유가 있습니다. 예를 들어 지불 채널 및 기타 스마트 계약에서 부정 행위에 대한 인센티브가 있으며 이더의 양이 한정되어 있기 때문에 소각된 이더는 모든 이더 보유자에게 소각된 가치를 효과적으로 분배합니다. (그들이 보유한 에테르의 양에 비례).


## 4. Transaction Recipient
\트랜잭션의 주요 "페이로드"는 값과 데이터의 두 필드에 포함됩니다. 트랜잭션에는 값과 데이터가 모두 있거나 값만 있거나 데이터만 있거나 값과 데이터가 모두 있을 수 있습니다. 네 가지 조합이 모두 유효합니다.

가치만 있는 거래는 지불 입니다. 데이터만 있는 트랜잭션은 호출 입니다. 가치와 데이터가 모두 있는 거래는 지불이자 호출입니다. 가치도 데이터도 없는 거래는 아마도 가스 낭비일 것입니다! 하지만 여전히 가능합니다.

이 모든 조합을 시도해 봅시다. 먼저 데모를 더 쉽게 읽을 수 있도록 지갑에서 소스 및 대상 주소를 설정합니다.

src  =  web3 . 에트 . 계정 [ 0 ] ; 
dst  =  web3 . 에트 . 계정 [ 1 ] ;
첫 번째 트랜잭션에는 값(결제)만 포함되고 데이터 페이로드는 포함되지 않습니다.

웹3 . 에트 . sendTransaction ( { from : src ,  to : dst , \
   value : web3 . utils . toWei ( 0.01 ,  "ether" ) ,  data : "" } ) ;
우리 지갑은 값은 있지만 데이터는 없는 거래를 보여주는 Parity 지갑 에서 볼 수 있듯이 보낼 값을 나타내는 확인 화면을 보여줍니다 .

가치는 있지만 데이터가 없는 거래를 보여주는 패리티 지갑
그림 1. 가치는 있지만 데이터가 없는 거래를 보여주는 패리티 지갑
다음 예에서는 값과 데이터 페이로드를 모두 지정합니다.

웹3 . 에트 . sendTransaction ( { from : src ,  to : dst , \
   value : web3 . utils . toWei ( 0.01 ,  "ether" ) ,  data : "0x1234 " } ) ;
우리 지갑은 값과 데이터가 있는 거래를 보여주는 Parity 지갑 에서 볼 수 있듯이 전송할 값과 데이터 페이로드를 나타내는 확인 화면을 보여줍니다 .

가치와 데이터가 있는 거래를 보여주는 패리티 지갑
그림 2. 가치와 데이터가 있는 거래를 보여주는 패리티 지갑
다음 트랜잭션은 데이터 페이로드를 포함하지만 값을 0으로 지정합니다.

웹3 . 에트 . sendTransaction ( { from : src ,  to : dst ,  값 : 0 ,  데이터 : "0x1234 " } ) ;
우리 지갑은 가치 가 없고 데이터만 있는 거래를 보여주는 패리티 지갑 에서 볼 수 있듯이 0 값과 데이터 페이로드를 나타내는 확인 화면을 보여줍니다 .

가치가 없고 데이터만 있는 거래를 보여주는 패리티 지갑
그림 3. 가치가 없고 데이터만 있는 트랜잭션을 보여주는 패리티 지갑
마지막으로, 마지막 트랜잭션에는 보낼 값이나 데이터 페이로드가 포함되어 있지 않습니다.

웹3 . 에트 . sendTransaction ( { from : src ,  to : dst ,  값 : 0 ,  데이터 : "" } ) ) ;
우리 지갑은 가치가 없고 데이터가 없는 거래를 보여주는 Parity 지갑 에서 볼 수 있듯이 가치가 0임을 나타내는 확인 화면을 보여줍니다 .

가치와 데이터가 없는 거래를 보여주는 패리티 지갑
그림 4. 가치와 데이터가 없는 트랜잭션을 보여주는 패리티 지갑


## 5. Transaction Value and Data
값이 포함된 이더리움 트랜잭션을 구성하면 지불 과 동일 합니다 . 이러한 트랜잭션은 대상 주소가 계약인지 여부에 따라 다르게 동작합니다.

EOA 주소의 경우 또는 블록체인에서 계약으로 플래그가 지정되지 않은 주소의 경우 Ethereum은 상태 변경을 기록하여 귀하가 보낸 값을 주소 잔액에 추가합니다. 주소가 이전에 확인되지 않은 경우 상태에 대한 클라이언트의 내부 표현에 추가되고 잔액은 귀하의 지불 가치로 초기화됩니다.

대상 주소(to)가 계약이면 EVM은 계약을 실행하고 트랜잭션의 데이터 페이로드에 이름이 지정된 함수를 호출하려고 시도합니다. 트랜잭션에 데이터가 없는 경우 EVM은 대체 기능 을 호출하고 해당 기능이 지불 가능한 경우 실행하여 다음에 무엇을 할지 결정합니다. 폴백 기능에 코드가 없으면 트랜잭션의 효과는 지갑에 지불하는 것과 마찬가지로 계약 잔액을 늘리는 것입니다. 폴백 기능 또는 미지급 폴백 기능이 없는 경우 트랜잭션이 되돌려집니다.

계약은 함수가 호출될 때 즉시 예외를 발생시키거나 함수에 코딩된 조건에 의해 결정된 대로 들어오는 지불을 거부할 수 있습니다. 함수가 성공적으로 종료되면(예외 없이) 계약의 상태가 계약의 이더 잔액 증가를 반영하도록 업데이트됩니다.


## 6. Special Transaction: Contract Creation
트랜잭션에 데이터가 포함된 경우 계약 주소로 주소가 지정될 가능성이 큽니다. 그렇다고 해서 데이터 페이로드를 EOA로 보낼 수 없다는 의미는 아닙니다. 이는 이더리움 프로토콜에서 완전히 유효합니다. 그러나 이 경우 데이터의 해석은 EOA에 액세스하는 데 사용하는 지갑에 달려 있습니다. Ethereum 프로토콜에서는 무시됩니다. 대부분의 지갑은 또한 그들이 제어하는 ​​EOA에 대한 트랜잭션에서 수신된 모든 데이터를 무시합니다. 미래에는 지갑이 계약 방식으로 데이터를 해석할 수 있도록 하는 표준이 등장하여 트랜잭션이 사용자 지갑 내에서 실행되는 기능을 호출할 수 있게 될 수 있습니다. 결정적인 차이점은 EOA에 의한 데이터 페이로드의 해석은 계약 실행 과 달리 이더리움의 합의 규칙의 적용을 받지 않는다는 것 입니다.

지금은 트랜잭션이 계약 주소로 데이터를 전달한다고 가정해 보겠습니다. 이 경우 데이터는 EVM에서 계약 호출 로 해석 됩니다 . 대부분의 계약은 이 데이터를 보다 구체적으로 함수 호출 로 사용하고 , 명명된 함수를 호출하고 인코딩된 인수를 함수에 전달합니다.

ABI 호환 계약(모든 계약이 있다고 가정할 수 있음)으로 전송된 데이터 페이로드는 다음의 16진수 직렬화 인코딩입니다.

기능 선택기
함수 프로토타입의 Keccak-256 해시의 처음 4바이트입니다. 이렇게 하면 계약에서 호출하려는 기능을 명확하게 식별할 수 있습니다.

함수 인수
ABI 사양에 정의된 다양한 기본 유형에 대한 규칙에 따라 인코딩된 함수의 인수입니다.

에서는 [solidity_faucet_example]는 , 우리는 인출하는 기능을 정의 :

기능 철회 ( 단위  철회_amount ) 공개 {
함수 의 프로토타입 은 함수 이름을 포함하는 문자열로 정의되며, 그 뒤에 괄호로 묶이고 쉼표로 구분된 각 인수의 데이터 유형이 옵니다. 여기서 함수 이름은 철회이고 uint(uint256의 별칭)인 단일 인수를 사용하므로 철회의 프로토타입은 다음과 같습니다.

철회 ( uint256 )
이 문자열의 Keccak-256 해시를 계산해 보겠습니다.

> web3.utils.sha3("취소(uint256)");
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
해시의 처음 4바이트는 0x2e1a7d4d입니다. 그것이 우리가 호출하고자 하는 함수를 계약에 알려줄 "함수 선택기" 값입니다.

다음으로 인수로 전달할 값을 계산해 보겠습니다. 0.01 이더를 인출하고 싶습니다. wei로 표시되는 16진수 직렬화된 빅엔디안 부호 없는 256비트 정수로 인코딩해 보겠습니다.

> 인출 금액 = web3.utils.toWei(0.01, "에테르");
'10000000000000000'
> 출금_금액_헥스 = web3.utils.toHex(출금_금액);
'0x2386f26fc10000'
이제 함수 선택기를 금액(32바이트로 채워짐)에 추가합니다.

2e1a7d4d0000000000000000000000000000000000000000000000002386f26fc10000
이것은 우리 거래에 대한 데이터 페이로드로, 인출 기능을 호출하고 0.01 ether를 인출 금액으로 요청합니다.

## 7. Digital Signatures
언급해야 하는 한 가지 특별한 경우 는 블록체인에서 새 계약 을 생성하여 향후 사용을 위해 배포 하는 트랜잭션입니다 . 계약 생성 트랜잭션은 0 주소 라고 하는 특수 대상 주소로 전송됩니다 . 계약 등록 트랜잭션의 to 필드에는 주소 0x0이 포함됩니다. 이 주소는 EOA(해당 개인-공개 키 쌍이 없음)나 계약을 나타내지 않습니다. 절대 이더를 사용하거나 거래를 시작할 수 없습니다. "이 계약을 작성하십시오"라는 특별한 의미로 목적지로만 사용됩니다.

제로 주소는 계약 생성만을 위한 것이지만 때때로 다양한 주소에서 지불을 받습니다. 이에 대한 두 가지 설명이 있습니다. 우연히 발생하여 에테르를 잃어버리거나 의도적인 에테르 소진입니다(절대 사용할 수 없는 주소로 에테르를 고의적으로 파괴하는 것). 그러나 의도적으로 이더를 굽고 싶다면 네트워크에 의도를 분명히 하고 대신 특별히 지정된 굽기 주소를 사용해야 합니다.

0x00000000000000000000000000000000000dEaD
경고
지정된 소각 주소로 전송된 모든 에테르는 사용할 수 없게 되어 영원히 손실됩니다.

계약 생성 트랜잭션에는 계약을 생성할 컴파일된 바이트코드가 포함된 데이터 페이로드만 있으면 됩니다. 이 거래의 유일한 효과는 계약을 생성하는 것입니다. 새 계약을 시작 잔액으로 설정하려는 경우 값 필드에 이더 금액을 포함할 수 있지만 이는 전적으로 선택 사항입니다. 데이터 페이로드(계약 없음) 없이 계약 생성 주소로 값(이더)을 보내는 경우 효과는 소각 주소로 보내는 것과 동일합니다. 신용에 대한 계약이 없으므로 이더가 손실됩니다.

예를 들어 데이터 페이로드의 계약을 사용하여 0 주소에 대한 트랜잭션을 수동으로 생성하여 [intro_chapter] 에서 사용되는 Faucet.sol 계약을 생성할 수 있습니다 . 계약은 바이트코드 표현으로 컴파일해야 합니다. 이것은 Solidity 컴파일러로 할 수 있습니다:

$ solc --bin 수도꼭지.sol

바이너리 :
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060...
Remix 온라인 컴파일러에서도 동일한 정보를 얻을 수 있습니다.

이제 트랜잭션을 생성할 수 있습니다.

> src = web3.eth.accounts[0]; 
> 수도꼭지 코드 = \
  "0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606...f0029"; 
> web3.eth.sendTransaction({from: src, to: 0, 데이터: faucet_code, \
  가스: 113558, 가스가격: 200000000000});

"0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b"
주소가 0인 계약 생성의 경우에도 항상 to 매개변수를 지정하는 것이 좋습니다. 실수로 이더를 0x0으로 보내고 영원히 잃어버리는 비용이 너무 크기 때문입니다. 또한 gasPrice 및 gasLimit도 지정해야 합니다.

계약이 채굴되면 Etherscan에서 성공적으로 채굴된 계약을 보여주는 Etherscan 블록 탐색기에서 볼 수 있습니다 .

컨트랙트가 성공적으로 채굴되었음을 보여주는 Etherscan
그림 5. 성공적으로 채굴된 계약을 보여주는 Etherscan
계약에 대한 정보를 얻기 위해 거래 영수증을 볼 수 있습니다.

> web3.eth.getTransactionReceipt( \
  "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b");

{
  blockHash: "0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2",
  블록 번호: 3105256,
  계약 주소: "0xb226270965b43373e98ffc6e2c7693c17e2cf40b",
  누적 가스 사용: 113558,
  보낸 사람: "0x2a966a87db5913c1b22a59b0d8a11cc51c167a89",
  가스사용: 113558,
  로그: [],
  로그블룸: \
    "0x000000000000000000000000000000000000000000000000...00000",
  상태: "0x1",
  받는 사람: null,
  트랜잭션 해시: \
    "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b",
  트랜잭션 인덱스: 0
}
여기에는 계약 주소가 포함되며, 이전 섹션에서와 같이 계약에 자금을 보내고 받는 데 사용할 수 있습니다.

> 계약 주소 = "0xb226270965b43373e98ffc6e2c7693c17e2cf40b" 
> web3.eth.sendTransaction({보낸 사람: src, 받는 사람: 계약 주소, \
  값: web3.utils.toWei(0.1, "ether"), 데이터: ""});

"0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f"

> web3.eth.sendTransaction({from: src, to: contract_address, 값: 0, 데이터: \
  "0x2e1a7d4d000000000000000000000000000000000000000000000002386f26fc10000"});

"0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e"
잠시 후 두 거래 모두 Etherscan에서 볼 수 있습니다. Etherscan은 자금을 보내고 받기 위한 거래를 보여줍니다 .

자금을 보내고 받기 위한 거래를 보여주는 Etherscan
그림 6. 자금을 보내고 받는 트랜잭션을 보여주는 Etherscan


## 8. The Signature Prefix Value (v) and Public Key Recovery
지금까지 디지털 서명에 대한 자세한 내용은 다루지 않았습니다. 이 섹션에서는 디지털 서명이 작동하는 방식과 개인 키를 공개하지 않고 개인 키의 소유권 증명을 제시하는 데 디지털 서명을 사용하는 방법을 살펴봅니다.

타원 곡선 디지털 서명 알고리즘
이더리움에서 사용되는 디지털 서명 알고리즘은 ECDSA( Elliptic Curve Digital Signature Algorithm )입니다. [elliptic_curve] 에 설명된 대로 타원 곡선 개인-공개 키 쌍을 기반으로 합니다.

디지털 서명은 Ethereum에서 세 가지 용도로 사용됩니다(다음 사이드바 참조). 첫째, 서명은 암시적으로 이더리움 계정의 소유자인 개인 키의 소유자가 이더 의 지출 또는 계약 실행을 승인 했음을 증명합니다 . 둘째, 부인 방지를 보장 합니다. 승인 증명은 부인할 수 없습니다. 셋째, 서명은 거래 데이터가 서명된 후 거래 데이터가 변경되지 않았으며 누구도 수정할 수 없음을 증명합니다 .

Wikipedia의 디지털 서명 정의
디지털 서명은 디지털 메시지 나 문서의 진위를 표현하기위한 수학적 기법이다. 유효한 디지털 서명은 수신자가 메시지가 알려진 발신자에 의해 작성되었음을 믿을 수 있는 이유(인증), 발신자가 메시지를 보낸 것을 거부할 수 없음(부인 방지), 메시지가 전송 중에 변경되지 않았음을(무결성) 제공합니다. .

출처: https://en.wikipedia.org/wiki/Digital_signature

디지털 서명 작동 방식
디지털 서명은 두 부분으로 구성된 수학적 체계입니다. 첫 번째 부분은 메시지(이 경우 트랜잭션)에서 개인 키(서명 키)를 사용하여 서명을 생성하는 알고리즘입니다. 두 번째 부분은 메시지와 공개 키만 사용하여 누구나 서명을 확인할 수 있는 알고리즘입니다.

디지털 서명 만들기
이더리움의 ECDSA 구현에서 서명되는 "메시지"는 트랜잭션, 더 정확하게는 트랜잭션의 RLP 인코딩 데이터의 Keccak-256 해시입니다. 서명 키는 EOA의 개인 키입니다. 결과는 서명입니다.

S i g = F sig ( F keccak256 ( m ) , k )
어디:

k 는 서명 개인 키입니다.

m 은 RLP로 인코딩된 트랜잭션입니다.

F keccak256 은 Keccak-256 해시 함수입니다.

F sig 는 서명 알고리즘입니다.

Sig 는 결과 서명입니다.

함수 F sig 는 일반적으로 r 및 s 라고 하는 두 값으로 구성된 서명 Sig 를 생성합니다 .

S i g = ( r , s )
서명 확인
서명을 확인하려면 서명( r 및 s ), 직렬화된 트랜잭션 및 서명을 생성하는 데 사용된 개인 키에 해당하는 공개 키가 있어야 합니다. 기본적으로 서명 확인은 "이 공개 키를 생성한 개인 키의 소유자만 이 거래에서 이 서명을 생성할 수 있음"을 의미합니다.

서명 확인 알고리즘은 메시지(즉, 우리가 사용하는 트랜잭션의 해시), 서명자의 공개 키 및 서명( r 및 s 값)을 취하고 서명이 이 메시지 및 공개 키에 대해 유효하면 true를 반환합니다.

ECDSA 수학
이전에 언급했듯이 서명은 r 및 s 라는 두 값으로 구성된 서명을 생성하는 수학 함수 F sig 에 의해 생성됩니다 . 이 섹션에서는 F sig 함수 를 더 자세히 살펴봅니다.

서명 알고리즘은 먼저 암호학적으로 안전한 방식으로 임시 (임시) 개인 키를 생성합니다 . 이 임시 키는 이더리움 네트워크에서 서명된 트랜잭션을 관찰하는 공격자가 보낸 사람의 실제 개인 키를 계산할 수 없도록 하기 위해 r 및 s 값을 계산하는 데 사용됩니다 .

[pubkey] 에서 알 수 있듯이 임시 개인 키는 해당 (임시) 공개 키를 파생하는 데 사용되므로 다음을 수행합니다.

임시 개인 키로 사용되는 암호학적으로 안전한 난수 q

해당 임시 공개 키 Q , q 및 타원 곡선 생성기 지점 G에서 생성

디지털 서명 의 r 값은 임시 공개 키 Q 의 x 좌표입니다 .

거기에서, 알고리즘은 계산 의의 서명 값, 그러한가 :

s ≡ q -1 ( Keccak256 ( m ) + r * k ) ( 모드 p )
어디:

q 는 임시 개인 키입니다.

r 은 임시 공개 키 의 x 좌표입니다.

k 는 서명(EOA 소유자의) 개인 키입니다.

m 은 트랜잭션 데이터입니다.

p 는 타원 곡선의 주요 차수입니다.

검증은 서명 생성 함수의 역이며, r 및 s 값과 발신자의 공개 키를 사용 하여 타원 곡선(서명 생성에 사용되는 임시 공개 키)의 한 점인 값 Q 를 계산합니다 . 단계는 다음과 같습니다.

모든 입력이 올바르게 구성되었는지 확인

계산 w = s -1 mod p

계산 u 1 = Keccak256 ( m ) * w mod p

계산 u 2 = r * w mod p

마지막으로 타원 곡선 Q ≡ u 1 * G + u 2 * K     ( mod p ) 의 점을 계산합니다.

어디:

r 및 s 는 서명 값입니다.

K 는 서명자(EOA 소유자)의 공개 키입니다.

m 은 서명된 트랜잭션 데이터입니다.

G 는 타원 곡선 생성기 점입니다.

p 는 타원 곡선의 주요 차수입니다.

계산된 점 Q 의 x 좌표 가 r 과 같으면 검증자는 서명이 유효하다는 결론을 내릴 수 있습니다.

서명을 확인할 때 개인 키는 알려지거나 공개되지 않습니다.

팁
ECDSA는 필연적으로 상당히 복잡한 수학 부분입니다. 전체 설명은 이 책의 범위를 벗어납니다. 온라인상의 여러 훌륭한 가이드가 단계별로 안내합니다. "ECDSA 설명"을 검색하거나 http://bit.ly/2r0HhGB에서 시도해 보십시오 .

거래 서명 실습
유효한 트랜잭션을 생성하려면 발신자가 타원 곡선 디지털 서명 알고리즘을 사용하여 메시지에 디지털 서명해야 합니다. "트랜잭션 서명"이라고 할 때 실제로는 "RLP 직렬화된 트랜잭션 데이터의 Keccak-256 해시에 서명"을 의미합니다. 서명은 트랜잭션 자체가 아니라 트랜잭션 데이터의 해시에 적용됩니다.

이더리움에서 트랜잭션에 서명하려면 발신자가 다음을 수행해야 합니다.

nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0의 9개 필드를 포함하는 트랜잭션 데이터 구조를 만듭니다.

트랜잭션 데이터 구조의 RLP로 인코딩된 직렬화된 메시지를 생성합니다.

이 직렬화된 메시지의 Keccak-256 해시를 계산합니다.

ECDSA 서명을 계산하고 원래 EOA의 개인 키로 해시에 서명합니다.

ECDSA 서명의 계산된 v, r 및 s 값을 트랜잭션에 추가합니다.

특수 서명 변수 v는 ECDSArecover 기능이 서명을 확인하는 데 도움이 되는 체인 ID와 복구 식별자의 두 가지를 나타냅니다. 27 또는 28 중 하나로 계산되거나 체인 ID에 35 또는 36을 더한 값으로 계산됩니다. 체인 ID에 대한 자세한 내용은 EIP-155를 사용한 원시 트랜잭션 생성을 참조하십시오 . 복구 식별자("구식" 서명의 경우 27 또는 28, 전체 Spurious Dragon 스타일 트랜잭션의 경우 35 또는 36)는 공개 키의 y 구성 요소의 패리티를 나타내는 데 사용됩니다( 서명 접두사 값( v) 및 자세한 내용은 공개 키 복구 ).

노트
블록 #2,675,000에서 이더리움은 "Spurious Dragon" 하드 포크를 구현했으며, 이 하드 포크는 무엇보다도 트랜잭션 재생 보호(한 네트워크에 대한 트랜잭션이 다른 네트워크에서 재생되는 것을 방지)를 포함하는 새로운 서명 체계를 도입했습니다. 이 새로운 서명 체계는 EIP-155에 지정되어 있습니다. 이 변경은 트랜잭션의 형식과 서명에 영향을 미치므로 두 가지 형식 중 하나를 취하고 해시되는 트랜잭션 메시지에 포함된 데이터 필드를 나타내는 세 가지 서명 변수(즉, v) 중 첫 번째 변수에 주의를 기울여야 합니다.

원시 트랜잭션 생성 및 서명
이 섹션에서는 npm으로 설치할 수 있는 ethereumjs-tx 라이브러리를 사용하여 원시 트랜잭션을 만들고 서명합니다. 이것은 지갑 내부에서 일반적으로 사용되는 기능 또는 사용자를 대신하여 트랜잭션에 서명하는 응용 프로그램을 보여줍니다. 이 예제의 소스 코드 는 책의 GitHub 리포지토리 에 있는 raw_tx_demo.js 파일에 있습니다 .

링크: 코드 / web3js / raw_tx / raw_tx_demo . js []
예제 코드를 실행하면 다음 결과가 생성됩니다.

$ 노드 raw_tx_demo.js
RLP로 인코딩된 Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx 해시: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
서명된 원시 트랜잭션: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
EIP-155를 사용한 원시 트랜잭션 생성
EIP-155 "단순 재생 공격 보호" 표준은 서명 전에 트랜잭션 데이터 내부에 체인 식별자 를 포함하는 재생 공격 보호 트랜잭션 인코딩을 지정합니다 . 이는 한 블록체인(예: 이더리움 메인 네트워크)에 대해 생성된 트랜잭션이 다른 블록체인(예: 이더리움 클래식 또는 Ropsten 테스트 네트워크)에서 유효하지 않음을 보장합니다. 따라서 한 네트워크에서 브로드캐스트된 트랜잭션은 다른 네트워크에서 재생할 수 없으므로 표준 이름입니다.

EIP-155는 트랜잭션 데이터 구조의 주요 6개 필드, 즉 체인 식별자 0 및 0에 3개의 필드를 추가합니다. 이 3개의 필드 는 인코딩 및 해시되기 전에 트랜잭션 데이터에 추가됩니다 . 따라서 나중에 서명이 적용되는 트랜잭션의 해시를 변경합니다. 서명되는 데이터에 체인 식별자를 포함하면 체인 식별자가 수정되면 서명이 무효화되므로 트랜잭션 서명은 변경을 방지합니다. 따라서 EIP-155는 서명의 유효성이 체인 식별자에 따라 달라지기 때문에 트랜잭션이 다른 체인에서 재생되는 것을 불가능하게 합니다.

체인 식별자 필드는 체인 식별자에 설명된 대로 트랜잭션이 의미하는 네트워크에 따라 값을 취합니다 .

표 1. 체인 식별자
체인	체인 ID
이더리움 메인넷

1

Morden(구식), Expanse

2

롭스텐

삼

린케비

4

루트스톡 메인넷

30

루트스톡 테스트넷

31

코반

42

이더리움 클래식 메인넷

61

이더리움 클래식 테스트넷

62

Geth 비공개 테스트넷

1337

결과 트랜잭션 구조는 RLP로 인코딩되고 해시되고 서명됩니다. 서명 알고리즘은 v 접두사에서도 체인 식별자를 인코딩하도록 약간 수정됩니다.

자세한 내용 은 EIP-155 사양을 참조하십시오 .

서명 접두사 값(v) 및 공개 키 복구
트랜잭션 구조 에서 언급했듯이 트랜잭션 메시지에는 "from" 필드가 포함되지 않습니다. 발신자의 공개 키를 ECDSA 서명에서 직접 계산할 수 있기 때문입니다. 공개 키가 있으면 주소를 쉽게 계산할 수 있습니다. 서명자의 공개 키를 복구하는 프로세스를 공개 키 복구 라고 합니다.

ECDSA Math 에서 계산된 값 r과 s가 주어지면 두 개의 가능한 공개 키를 계산할 수 있습니다.

먼저 서명에 있는 x 좌표 r 값 에서 두 개의 타원 곡선 점 R 및 R ' 를 계산 합니다. 타원 곡선은 x축을 가로질러 대칭이기 때문에 두 개의 점이 있으므로 임의의 값 x에 대해 x축의 양쪽에 하나씩 곡선에 맞는 두 개의 가능한 값이 있습니다.

r에서 r 의 곱셈 역인 r -1 도 계산 합니다.

마지막으로, 계산 Z 는 IS, n은 상기 메시지의 해시 최하위 비트, 여기서 n은 타원 곡선의 순서이다.

두 가지 가능한 공개 키는 다음과 같습니다.

K 1 = r –1 ( sR – zG )
과:

K 2 = r –1 ( sR ' – zG )
어디:

K 1 및 K 2 는 서명자의 공개 키에 대한 두 가지 가능성입니다.

r -1 은 서명의 r 값에 대한 곱셈 역입니다.

s 는 서명의 s 값입니다.

R 및 R ' 은 임시 공개 키 Q에 대한 두 가지 가능성입니다 .

z 는 메시지 해시 의 n- 최하위 비트입니다.

G 는 타원 곡선 생성기 점입니다.

일을 더 효율적으로 만들기 위해 트랜잭션 서명에는 두 개의 가능한 R 값 중 임시 공개 키가 무엇인지 알려주는 접두사 값 v가 포함 됩니다. v가 짝수이면 R 이 올바른 값입니다. v가 홀수이면 R ' 입니다. 그렇게 하면 R 에 대해 하나의 값만 계산 하고 K 에 대해 하나의 값만 계산해야 합니다 .


## 9. Separating Signing and Transmission (Offline Signing)
트랜잭션이 서명되면 이더리움 네트워크로 전송할 준비가 된 것입니다. 트랜잭션 생성, 서명 및 브로드캐스트의 세 단계는 일반적으로 단일 작업으로 발생합니다(예: web3.eth.sendTransaction 사용). 그러나 Raw Transaction Creation and Signing 에서 보았듯이 두 단계로 트랜잭션을 생성하고 서명 할 수 있습니다. 서명된 트랜잭션이 있으면 web3.eth.sendSignedTransaction을 사용하여 전송할 수 있습니다. 이 트랜잭션은 16진수로 인코딩되고 서명된 트랜잭션을 가져와 이더리움 네트워크에서 전송합니다.

거래의 서명과 전송을 분리하려는 이유는 무엇입니까? 가장 일반적인 이유는 보안입니다. 트랜잭션에 서명하는 컴퓨터에는 메모리에 로드된 잠금 해제된 개인 키가 있어야 합니다. 전송을 수행하는 컴퓨터는 인터넷에 연결되어 있어야 하며 이더리움 클라이언트를 실행해야 합니다. 이 두 기능이 한 컴퓨터에 있다면 온라인 시스템에 개인 키가 있는 것이므로 매우 위험합니다. 서로 다른 시스템(각각 오프라인 및 온라인 장치)에서 서명 및 전송 및 수행 기능을 분리하는 것을 오프라인 서명 이라고 하며 일반적인 보안 관행입니다.

Ethereum 트랜잭션의 오프라인 서명은 프로세스를 보여줍니다.

계정의 현재 상태, 특히 현재 논스 및 사용 가능한 자금을 검색할 수 있는 온라인 컴퓨터에서 서명되지 않은 트랜잭션을 만듭니다.

QR 코드 또는 USB 플래시 드라이브를 통해 서명되지 않은 트랜잭션을 트랜잭션 서명을 위해 "에어 갭(air-gapped)" 오프라인 장치로 전송합니다.

QR 코드 또는 USB 플래시 드라이브를 통해 Ethereum 블록체인에서 브로드캐스트하기 위해 서명된 트랜잭션(다시)을 온라인 장치로 전송합니다.

Ethereum 거래의 오프라인 서명
그림 7. 이더리움 거래의 오프라인 서명
필요한 보안 수준에 따라 "오프라인 서명" 컴퓨터는 격리되고 방화벽이 있는 서브넷(온라인이지만 분리됨)에서 에어 갭 시스템 으로 알려진 완전히 오프라인 시스템에 이르기까지 온라인 컴퓨터와 다양한 수준의 분리를 가질 수 있습니다. . 에어 갭 시스템에서는 네트워크 연결이 전혀 없습니다. 컴퓨터는 "에어" 간격으로 온라인 환경과 분리되어 있습니다. 거래에 서명하려면 데이터 저장 매체 또는 (더 나은) 웹캠 및 QR 코드를 사용하여 에어 갭 컴퓨터와 거래를 전송합니다. 물론 이것은 서명하려는 모든 트랜잭션을 수동으로 전송해야 한다는 것을 의미하며 이는 확장되지 않습니다.

완전한 에어 갭 시스템을 활용할 수 있는 환경은 많지 않지만 약간의 격리라도 상당한 보안 이점을 제공합니다. 예를 들어, 메시지 대기열 프로토콜만 허용하는 방화벽이 있는 격리된 서브넷은 온라인 시스템에 서명하는 것보다 훨씬 감소된 공격 표면과 훨씬 높은 보안을 제공할 수 있습니다. 이를 위해 많은 회사에서 ZeroMQ(0MQ)와 같은 프로토콜을 사용합니다. 이와 같은 설정을 사용하면 트랜잭션이 직렬화되고 서명을 위해 대기열에 추가됩니다. 대기열 프로토콜은 TCP 소켓과 유사한 방식으로 직렬화된 메시지를 서명 컴퓨터로 전송합니다. 서명 컴퓨터는 대기열에서 직렬화된 트랜잭션을 (주의 깊게) 읽고 적절한 키로 서명을 적용하고 나가는 대기열에 배치합니다.


## 10. Transaction Propagation
이더리움 네트워크는 "플러드 라우팅" 프로토콜을 사용합니다. 각 이더리움 클라이언트는 (이상적으로는) 메쉬 네트워크를 형성하는 피어 투 피어(P2P) 네트워크 에서 노드 역할을 합니다. 특별한 네트워크 노드는 없습니다. 모두 동일한 피어로 작동합니다. 우리는 "노드"라는 용어를 P2P 네트워크에 연결되어 참여하는 이더리움 클라이언트를 지칭하는 데 사용할 것입니다.

트랜잭션 전파는 서명된 트랜잭션을 생성(또는 오프라인에서 수신)하는 원래 이더리움 노드에서 시작됩니다. 트랜잭션이 검증된 다음 원래 노드에 직접 연결된 다른 모든 이더리움 노드로 전송됩니다 . 평균적으로 각 이더리움 노드는 인접 노드라고 하는 최소 13개의 다른 노드에 대한 연결을 유지합니다 . 각 인접 노드는 트랜잭션을 수신하는 즉시 트랜잭션의 유효성을 검사합니다. 그들이 유효하다고 동의하면 사본을 저장하고 모든 이웃에게 전파합니다(원본 제외). 결과적으로 트랜잭션은 원래 노드에서 바깥쪽으로 파문을 일으켜 범람합니다.네트워크의 모든 노드가 트랜잭션 사본을 가질 때까지 네트워크를 통해 노드는 전파하는 메시지를 필터링할 수 있지만 기본적으로 수신하는 모든 유효한 트랜잭션 메시지를 전파하는 것입니다.

단 몇 초 만에 이더리움 트랜잭션은 전 세계의 모든 이더리움 노드로 전파됩니다. 각 노드의 관점에서 트랜잭션의 출처를 식별하는 것은 불가능합니다. 노드로 보낸 이웃은 트랜잭션의 발신자이거나 이웃 중 하나로부터 트랜잭션을 수신했을 수 있습니다. 트랜잭션의 출처를 추적하거나 전파를 방해하려면 공격자가 모든 노드의 상당 부분을 제어해야 합니다. 이것은 특히 블록체인 네트워크에 적용되는 P2P 네트워크의 보안 및 개인 정보 보호 설계의 일부입니다.


## 11. Recording on the Blockchain
이더리움의 모든 노드는 동일한 피어이지만 일부는 채굴 자가 운영하며 고성능 GPU(그래픽 처리 장치)가 있는 컴퓨터인 채굴 농장에 트랜잭션과 블록을 공급합니다 . 마이닝 컴퓨터는 후보 블록에 트랜잭션을 추가 하고 후보 블록을 유효하게 만드는 작업 증명 을 찾으려고 시도 합니다. 이에 대해서는 [합의] 에서 더 자세히 논의할 것 입니다.

너무 자세히 설명하지 않아도 유효한 트랜잭션은 결국 트랜잭션 블록에 포함되어 이더리움 블록체인에 기록됩니다. 블록으로 채굴되면 트랜잭션은 계정 잔액을 수정하거나(단순 결제의 경우) 내부 상태를 변경하는 계약을 호출하여 Ethereum 싱글톤의 상태도 수정합니다. 이러한 변경 사항은 이벤트 를 포함할 수 있는 거래 영수증 의 형태로 거래와 함께 기록 됩니다 . 우리는 [evm_chapter] 에서 이 모든 것을 훨씬 더 자세히 조사할 것 입니다.

생성에서 EOA에 의한 서명, 전파 및 최종 채굴에 이르는 여정을 완료한 트랜잭션은 싱글톤의 상태를 변경하고 블록체인에 지울 수 없는 표시를 남겼습니다.


## 12. Multiple-Signature (Multisig) Transactions
Bitcoin의 스크립팅 기능에 익숙하다면 여러 당사자가 거래에 서명할 때만 자금을 사용할 수 있는 Bitcoin 다중 서명 계정을 생성할 수 있다는 것을 알고 있습니다(예: 2/4 서명 또는 3/2 서명). Ethereum의 기본 EOA 가치 거래에는 다중 서명에 대한 조항이 없습니다. 그러나 임의의 서명 제한은 이더와 토큰의 전송을 모두 처리하기 위해 생각할 수 있는 모든 조건의 스마트 계약에 의해 시행될 수 있습니다.

이 기능을 활용하려면 다중 서명 요구 사항 또는 지출 한도(또는 둘의 조합)와 같이 원하는 지출 규칙으로 프로그래밍된 "지갑 계약"으로 이더를 전송해야 합니다. 그런 다음 지갑 계약은 지출 조건이 충족되면 승인된 EOA가 요청하면 자금을 보냅니다. 예를 들어, 다중 서명 조건에서 이더를 보호하려면 다중 서명 계약으로 이더를 전송하십시오. 다른 계정으로 자금을 보내려고 할 때마다 필요한 모든 사용자는 일반 지갑 앱을 사용하여 계약으로 거래를 보내야 하며, 최종 거래 를 수행하기 위해 계약을 효과적으로 승인해야 합니다 .

이러한 계약은 로컬 코드를 실행하기 전에 여러 서명을 요구하거나 다른 계약을 트리거하도록 설계할 수도 있습니다. 체계의 보안은 궁극적으로 다중서명 계약 코드에 의해 결정됩니다.

다중 서명 거래를 스마트 계약으로 구현하는 기능은 이더리움의 유연성을 보여줍니다. 그러나 추가 유연성으로 인해 다중 서명 체계의 보안을 약화시키는 버그가 발생할 수 있으므로 이는 양날의 검입니다. 사실, 최소한 단순한 M-of-N 다중 서명 체계에 대해 스마트 계약의 필요성을 제거하는 다중 서명 명령을 EVM에 생성하는 제안이 많이 있습니다. 이는 핵심 합의 규칙의 일부이며 강력하고 안전한 것으로 입증된 비트코인의 다중 서명 시스템과 동일합니다.


## 13. Conclusions
트랜잭션은 이더리움 시스템의 모든 활동의 시작점입니다. 트랜잭션은 이더리움 가상 머신이 계약을 평가하고, 잔액을 업데이트하고, 더 일반적으로 이더리움 블록체인의 상태를 수정하도록 하는 "입력"입니다. 다음으로 우리는 스마트 계약에 대해 훨씬 더 자세히 작업하고 Solidity 계약 지향 언어로 프로그래밍하는 방법을 배웁니다.


